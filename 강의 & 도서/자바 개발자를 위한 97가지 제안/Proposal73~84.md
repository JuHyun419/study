## PROPOSAL 73 ~ PROPOSAL 84

### 73 단순한 값 객체 (스티브 프리먼)
  - 값 객체(VO - Value Object)를 표현하는 클래스에는 게터와 세터가 필요하지 않다.
  - 게터의 역할은 객체가 값을 표현하는 방법을 캡슐화하고 코드 전체에 일관된 접근을 제공하는 것이다.
  - 또한 별칭(Alias)으로부터 보호하는 역할도 한다.
  - 이러한 스타일은 자바빈의 초창기부터 시작되었다.
  - 필자는 몇 년 전, 다른 동료들이 그랬듯 필요한 게터를 중복해서 정의하는 방법에 피로를 느끼고, 값 객체를 내 방식으로 단순화하기 시작했다.
  - 즉, C의 구조체처럼 모든 필드를 public final로 선언한 것이다.

```java
public class Coordinate {
  public final Latitude latitude;
  public final Longitude longitude;
  
  public Coordinate(Latitude latitude, Longitude longitude) {
    this.latitude = latitude;
    this.longitude = longitude;
    }
  }
...
```

  - 위와 같은 코드를 작성할 수 있던 이유는 위 객체가 불변(복제는 유의하자!)이며, 개인적으로 클래스의 상속이나 한 클래스에 너무 많은 기능을 구현하는 것을 선호하지 않기 때문이다.
  - 값 객체를 단순화하는 것은 타입의 역할을 명확히 하는 데 유용한 규칙이며 코드를 읽는 데 방해가 되는 요소도 줄일 수 있는 방법이다.
  - 게다가 리팩토링도 쉬우며 코드의 도메인을 더 잘 표현하는 메서드를 어떤 타입에 추가해야 하는지를 더 확실히 알 수 있다.
  - 간혹 값 객체의 행위적인 기능이 더 중요한 경우에도 필드는 비공개로 유지하고 메서드로 필요한 것을 표현할 수 있게 되었다.
  - 결국 자바 언어 팀도 이 점을 깨닫고 자바 14에서 드디어 레코드(record) 구조체를 선보였다.

<br>

### 74 모듈 선언에 주의해야 하는 이유 (니콜라이 팔로그)
  - 자바 모듈을 생성할 때는 모듈 선언(module-info.java 파일)이 가장 중요한 소스 파일이다.
  - 각 모듈 파일이 전체 JAR를 표현하며 다른 JAR 파일과의 상호작용을 정의하므로 모듈 선언에 주의해야 한다.
  - 어떤점을 주의해야 하는지 살펴보자.

#### 모듈 선언은 깔끔하게 유지하자
  - 모듈 선언 역시 코드이므로 같은 코드로 취급하고 코딩 스타일을 적용해야 한다.
  - 어떤 결정이든 코드의 스타일을 정의한 문서가 있다면 그 결정을 문서에 추가하자.

#### 모듈 선언에 주석을 추가하자
#### 모듈 선언을 리뷰하자

<br>

### 75 의존성을 잘 관리하자 (브라이언 베르메르)
  - 요즘의 자바 개발은 서드파티(third-party) 라이브러리에 크게 의존한다.
  - 메이븐이나 그레이들은 공개된 패키지를 쉽게 가져와 사용할 수 있는 메커니즘을 제공한다.
  - 개발자는 반복적인 작업보다는 특정 비즈니스 로직에 집중하기를 원하므로 귀찮은 작업을 대신해 줄 프레임워크와 라이브러리를 잘 선택해 사용해야 한다.
  - 코드와 팀원의 기여를 다루는 방법을 보면, 메인(이전에는 마스터) 브랜치에 새로운 코드를 머지(merge)하기 전에 가장 먼저 통과해야 할 품질 보증 조치로 코드 리뷰 같은 절차를 도입하곤 한다.
  - 또는 품질 관리 절차로 짝 프로그래밍을 도입하는 경우도 있다.
  - 하지만 의존성을 다루는 방법은 코드를 다루는 방법과는 크게 다르다.
  - 의존성은 대부분 아무런 검증 없이 적용하곤 한다.
  - 더 중요한 것은 최상위 의존성의 경우 대부분 여러 계층으로 전파되는 전이 의존성으로 포함된다는 점이다.
  - 예를 들어, 2백 줄의 스프링 애플리케이션에 5개의 직접(direct) 의존성을 추가하면 총 60개의 의존성이 더 추가되며, 그로 인해 50만 줄의 코드를 프로덕션 환경에 배포하게 된다.
  - 취약점이 있는 의존성
    - 보안적인 측면에서, 의존 패키지에 알려진 취약점은 없는지 확인해야 한다
  - 의존성의 갱신
    - 의존성은 현명하게 선택해야 한다.
    - 오래되었거나 잘 유지되지 않은 라이브러리에 의존하는 것은 크나큰 위험이다.
    - 항상 최신 상태를 유지하고 싶다면 새 버전이 출시되었는지를 확인해야 한다.
    - 메이븐 & 그레이들은 다음 명령어를 통해 새 버전의 출시 여부를 확인할 수 있다.

```html
// 메이븐
mvn versions:display-dependency-updates

// 그레이들
gradle dependencyUpdates -Drevision=release

```

<br>

### 76 '관심사 분리'가 중요한 이유 (데이브 팔리)
  - '관심사 분리(separation of concern)'이란 한 클래스는 한 가지 작업만, 한 메서드도 한 가지 작업만 수행해야 한다고 주장한다.
  - 즉 클래스와 메서드는 반드시 한 가지 결과에만 집중해야 한다는 뜻이다.

```java
assertEquals("2/3", Fractions.addFraction("1/3", "1/3"));
```

  - 위 코드는 2개의 문자열을 전달받는다. **그리고** 각 문자열을 파싱한 후 그 합을 계산한다. 정도로 서술할 수 있다.
  - 하지만 문제점이 있는데, 설명에 '그리고' 라는 말이 들어간다.
  - 즉 이는 문자열의 파싱 및 분수의 덧셈 이라는 두 가지 동작을 실행하고 있다.
  - 테스트를 다음과 같이 작성하면 어떨까?

<br>

```java
Fraction fraction = new Fraction(1, 3);
assertEquals(new Fraction(2, 3), fraction.add(new Fraction(1, 3)));
```

  - 위 문장의 add 메서드는 두 분수의 합을 리턴한다 고 할 수 있다.
  - 이 방법이 구현 및 테스트가 훨씬 쉬우며 코드의 내부도 이해하기 쉽다.
  - 게다가 더 모듈화되어 조합이 더 쉬우므로 훨씬 유연하다.

<br>

### 77 기술 면접은 학습할 가치가 있는 기술이다 (트리샤 지)
  - IT 업계는 개발자 면접을 진행하는 기술이 턱없이 부족하다.
  - 정말 웃긴 점은 절대 면접자가 실제로 개발 중인 환경에 적용할 실제 코드를 작성하도록 하지 않는다는 점이다.
  - 연주자의 이론 지식을 테스트하면서 실제 연주는 시켜보지 않는 것과 마찬가지다.
  - 다행인 것은, 다른 기술과 마찬가지로 면접 기술도 학습할 수 있다는 점이다.
  - 다른 기술을 습득하는 것과 마찬가지로 기술 면접에 어떤 것이 필요한지 알아보고 계속 연습하면 된다.
  - 면접에 떨어졌다고 해서 여러분이 좋은 개발자가 아니라는 뜻은 아니다.
  - 면접 기술도 개선할 수 있으며, 각 면접은 더 많은 데이터를 확보하고 연습할 수 있는 또 다른 기회다.

<br>

### 78 테스트 주도 개발 (데이브 팔리)
  - 테스트 주도 개발(TDD)은 광범위하게 잘못 이해되고 있다.
  - 고품질의 소프트웨어란 다음과 같은 속성을 갖는 코드를 의미한다.
    - 모듈성
    - 낮은 결합
    - 응집력
    - 적절한 관심사 분리
    - 정보 은폐
  - 테스트 가능한 코드는 이런 속성을 가지고 있다.
  - TDD는 테스트를 이용해 개발(디자인)을 주도하는 기법이다.
  - TDD에서는 테스트를 통과할 코드를 작성하기 전에 테스트를 먼저 작성한다.
  - 테스트를 먼저 작성하는 것이 중요하다.
  - 즉, 항상 '테스트가 가능한' 코드를 작성한다는 뜻이다.
  - 또한 커버리지는 문제가 되지 않는다는 것도 의미한다.
  - 테스트를 먼저 작성하면 자연스럽게 커저비리 역시 높아지므로 더는 이에 대해 걱정할 필요가 없다.
  - TDD는 소프트웨어 개발자의 능력을 확대한다.
  - 더 나은 프로그래머를 양산한다.
  - TDD는 매우 간단해서 '레드, 그린, 리팩토링(Red, Green, Refactoring)'의 순서만 지키면 된다.
    - 먼저 테스트를 작성한 후 테스트가 실패하는지 확인한다.(레드)
    - 테스트를 통과할 수 있는 최소한의 코드만 작성한 후 테스트가 통과하는지 확인한다.(그린)
    - 코드를 리팩토링하고 테스트를 계속 진행해서 깔끔하고 표현력이 풍부하며 우아하면서도 간단한 코드를 작성한다.(리팩토링)
  - 이 단계는 코드를 디자인하는 세 가지 절차를 표현한다.

#### 레드
  - 이 단계에서는 코드의 행위적 의도를 표현하는 것에 집중한다.
  - 즉, 코드의 공개용 인터페이스에만 집중하는 것이다.
  - 코드로 실행하려는 것만 집중해서 테스트하는 깔끔하고 좋은 코드를 작성하는 것만 생각하자.
  - 간단한 테스트를 작성해서 공개용 인터페이스의 디자인에만 집중하자.

#### 그린
  - 테스트를 통과하기 위한 최소한의 작업만 수행한다.
  - 그 방법이 설령 너무 소박해 보이더라도 그렇게 해야 한다.

#### 리팩토링
  - 일단 그린 상태로 돌아왔다면 안전하게 리팩토링이 가능하다.
  - 작고 간단한 단계를 만들고 테스트를 다시 실행해서 모든 것이 제대로 동작하는지 확인한다.
  - 리팩토링은 뒷전으로 미뤄둘 것이 아니다.
  - 오히려 디자인을 더 전략적으로 생각해 볼 수 있는 기회다.

#### 결론
  - 테스트를 통과할 때마다 리팩토링을 위해 업무 진행을 중단하는 연습을 하자.
  - 항상 코드를 살피복 '이보다 더 좋은 방법은 없는지' 생각해 보자.
  - TDD의 3단계는 서로 확실히 구분되므로 각 단계의 장점을 극대화하기 위해 여러분의 정신도 확실히 구분해야 한다.

<br>

### 79 bin 디렉터리에는 좋은 도구가 너무나 많다 (로드 힐튼)
  - 자바 개발자라면 누구나 컴파일을 위한 javac, 실행을 위한 java, 자바 애플리케이션의 패키징을 위한 jar 도구에 익숙할 것이다.
  - 하지만 JDK를 설치하면 그 외에도 다양한 도구가 함께 설치되는데, 이는 bin/ 디렉터리에 설치되어 있으며 PATH 환경 변수에 포함되었다면 어디든 호출할 수 있다.
 
#### jps
  - 실행중인 JVM을 찾기위해 ps -ef(aux) | grep java 명령을 자주 사용한다면 jps 도구를 사용하는 편이 훨씬 간편하다.
  - jps -l 은 주 클래스의 완전히 식별 가능한 이름
  - jps -m 명령은 main 메서드에 전달된 매개변수를,
  - jps -v 명령은 JVM 자체에 전달된 모든 매개변수를 보여준다.

#### javap
  - javap <클래스이름> 명령을 실행하면 해당 클래스 파일의 필드와 메서드를 볼 수 있다.
  - 그러므로 스칼라, 클로저, 그루비 같은 JVM 기반 언어로 작성된 코드를 이해하는 데도 도움이 된다.
  - javap -c <클래스이름> 명령을 실행하면 이 메서드의 완전한 바이트코드도 볼 수 있다.

#### jmap
  - jmap -heap <프로세스 ID> 명령은 JVM 프로세스의 메모리 공간에 대한 요약 정보를 출력한다.
  - 각 JVM의 메모리 세대별로 얼마나 많은 메모리를 사용하는지는 물론 힙 설정과 현재 사용중인 GC의 종류도 알 수 있다.
  - jmap -histo <프로세스 ID> 명령은 힙 안의 각 클래스, 클래스의 인스턴스 개수, 각 인스턴스가 소비하는 메모리의 크기 등을 막대그래프로 보여준다.

#### jhat
  - jmap 명령으로 생성한 파일을 이용해 jhat <힙 덤프 파일> 명령을 실행하면 로컬 웹서버를 실행한다.

#### 그 외 jinfo, jstack, jconsole, jvisualvm, jshell
    
<br>
    
### 80 자바 샌드박스를 벗어나자 (이안 F. 다윈)
  - 개인적으로든 업무에서든 자주 새로운 언어를 사용하고 학습해야 한다.
  - 다른 언어가 기본적으로 이미 익숙한 자바와 어떻게 다른지, 프로젝트에서 유용하게 활용할 수 있는 부분이 있는지를 깊이있게 확인해 보자.
  - 다시 말하면 새 언어를 시도해 보자.

<br>
    
### ~81 코루틴에 대한 고찰 (던 그리피스, 데이비드 그리피스)~

<br>
    
### 82 스레드는 인프라스트럭처로 취급해야 한다 (러셀 윈더)
  - 프로그래밍하면서 스택, 힙 등을 관리하는 자바 프로그래머는 극히 적을 것이다.
  - 대부분 자바 프로그래머가 알고 있는 동시성(concurrency)과 병렬성(parallelism)은 1960년대 운영체제 구축 이론을 바탕으로 한다.
  - 만일 코드가 동기화 구문, 락(lock), 뮤텍스(mutex) 등을 사용한다면 뭔가 잘못하고 있을 가능성이 크다.
  - 스택 공간과 힙 공간이 관리형 리소스인 것처럼 스레드 역시 관리형 리소스여야 한다.
  - 스레드를 명시적으로 생성하고 관리하는 것이 아닌 태스크를 생성하고 스레드 풀에 제출하는 방식이어야 한다.
  - 당연히 태스크는 단일 스레드여야 한다!
  - 여러 태스크가 서로 통신해야 한다면 공유 메모리 대신 스레드에 안전한 큐를 사용해야 한다.\

<br>
    
### 83 정말 좋은 개발자의 세 가지 특징 (쟌나 팟체이)
  - 첫 직장은 몇 년간 자바 개발자로 일하며 깔끔하고 우아한 코드를 작성하는데 집착했으며 코드를 최대한 완벽하게 만들기 위해 몇 번이고 리팩토링 했다.
  - 현재는 개발자를 위해 요구 사항을 제공하고 정의하는 역할을 수행하며 함께 일해왔다.
  - 시간이 지나며 기술적 능력 외에 정말 좋은 개발자가 갖추고 있는 특징을 더 잘 인지할 수 있게 되었다.

#### 첫 번째이자 가장 중요한 특징은 호기심이다.
  - 호기심은 문제를 해결하고 동작 방식을 이해하며 새로운 것을 구축하기를 원하는 동기가 된다.
  - 이 동기는 고객 및 이해 관계자와의 상호작용에도 적용될 수 있고, 또 그렇게 되어야 한다.

#### 두 번째와 세 번째 특징은 공감과 상상력이다.
  - 이 두 가지는 개발자가 최종 사용자의 입장이 되어 그들의 우선 순위와 소프트웨어 사용 경험을 이해하는 데 필요한 능력이다.
  - 또한 여러분의 기술적 전문성을 발휘해 당면한 과제를 위한 창의적인 해결책을 제시하는 데 필요한 능력이기도 하다.
  - 여러분이 스스로 의사 결정자와 직접 의사소통할 수 있다면 훨씬 효율적일뿐더러 더 나은 개발자가 될 수 있다.

#### 결론
  - 어쩌면 당연한 말처럼 들리겠지만 고객은 정말 중요하다.
  - 많은 콘퍼런스에서의 발표자가 개발자와 최종 사용자 사이의 벽을 허무는 것에 대한 중요성을 강조했다.
  - 그 중 일부는 개발자가 비즈니스 도메인에 대해 최대한 이해할 수 있도록 비즈니스팀에 합류시키기도 했다.
  - 따라서 고객을 이해하는 것은 미래이자 더 현명하게 일하는 방법이다.
  - 이런 기술을 습득한다면 여러분에게 새로운 문이 열릴 것이다.
