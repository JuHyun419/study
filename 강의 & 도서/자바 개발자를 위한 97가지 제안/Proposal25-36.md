## PROPOSAL 25 ~ PROPOSAL 30

### 25 지루하더라도 표준을 따르자 (아담 베이언)
  - 처음 J2EE로 등장해서 Java EE로, 지금은 자카르타 EE가 된 기술, 마이크로프로파일은 애플리케이션 서버가 구현해야 할 최소한의 API 집합을 정의했다.
  - J2EE의 장점 덕분에 J2EE API만 알면 애플리케이션 개발 및 배포가 가능했다.
  - 호환성이 높았기에 새로운 버전이 릴리스되거나 버전이 업그레이드 되더라도 쉬웠다.
  - 현재 브라우저도 호환성을 갖췄을 뿐 아니라 예전에는 서드파티 프레임워크에서만 지원하던 기능까지 지원하기 시작했다.
  - querySelector 기능은 모든 브라우저에서 사용할 수 있고, 제이쿼리의 DOM 접근 기능과 호환되는 기능을 제공한다.
  - 이제는 프레임워크 없이도 프론트엔드를 구현할 수 있다.
  - 브라우저의 하위 호환성은 점점 더 훌륭해지고 있다.
  - 어쨌든 모든 프레임워크는 브라우저 API를 사용하므로 **표준** 을 학습하면 프레임워크를 더 잘 이해할 수 있다.
  - 표준에 집중하면 시간이 지나면서 더 많은 지식을 확보할 수 있다.
  - 매우 효율적인 학습 방법이다.

<br>

### 26 자주 릴리스하면 위험을 줄일 수 있다 (크리스 오델)
  - '자주 릴리스하면 위험을 줄일 수 있다.' 그런데 얼마나 위험을 줄일 수 있다는 걸까?
  - 위험이란, 장애가 발생했을 때 받을 수 있는 최악의 영향과 장애가 발생할 가능성을 결합한 요소다.
  - 위험 = 장애의 가능성 x 최악의 영향
  - 핵심은, **작은 변경 사항을 자주 릴리스해서 장애 가능성을 줄이고 변경 위험을 낮추자.**

<br>

### 27 퍼즐에서 제품까지 (제시카 커)
  - 쉬웠던 프로그래밍이 20년이 지난 지금, 어려워진 이유는 ..
  - 문제를 해결하는 역할에서 제품을 성장시키는 역할로, 이미 정해진 올바름만 추구하는 역할에서 변화를 위해 무엇이 올바른지 최적화하는 역할로 바뀌었기 때문이다.
  - 경력이 쌓이면서 나의 시야는 더 넓어졌다.
  - 직업은 코드를 바꾸는 일이 아니라 변화를 설계하는 일이고, 코드는 그저 세부사항일 뿐이다.
  - '올바른' 제품은 한 가지로 정의할 수 없다.
  - 분명 많은 것이 올바르지 않게 '오동작'하지 않도록 주의해야 한다.

<br>

### 28 '풀스택 엔지니어'는 마음가짐이다 (마체이 발코비악)
  - 처음 자바 개발자로 일하기 시작한 2007년, 일상적인 웹 개발에 속하는 기술 스펙트럼은 매우 좁았다.
  - 데이터베이스는 대부분 관계형 데이터베이스, 프론트엔드 개발은 HTML, CSS 일부 자바스크립트를 활용하는 정도였다.
  - 자바 개발 자체도 주로 스프링, 스트럿츠와 하이버네이트를 결합해 작업하는 형태였다.
  - 당시 자바 개발자 대부분은 풀스택(Full-Stack) 개발자였다.
  - 2007년 이후 상황이 급변했는데, 사용자 인터페이스는 더 복잡해지고, 이런 복잡성을 다루기 위해 고수준 자바스크립트 프레임워크가 도입되었다.
  - 이제는 NoSQL 데이터베이스를 사용하며 큰 차이점을 보인다.
  - 카프카로 데이터를 스트리밍하고, 래빗MQ로 메시지를 처리하며 그 외 여러 기술을 사용한다.
  - 테라폼, 클라우드포메이션을 이용해 인프라 스트럭처를 셋업하거나 유지보수하는 책임도 맡으며, 심지어 k8s도 사용하거나 설정한다.
  - 이제는 프론트, 백, 데브옵스 등 역할이 분리되기에 이르렀다.
  - 모든 기술을 전문가 수준으로 다룰 수는 없다.
  - 중요한것은 어느 특정 분야로 스스로를 제한하지 않으면 작업을 대하는 태도가 달라진다는 점이다.
  - 따라서 풀스택 개발자는 결국 마음가짐이다. 할 수 있다는 태도로 시니어이면서 동시에 주니어가 되는 것이다.

<br>

### 29 가비지 컬렉션은 나의 친구 (홀리 쿠민스)
  - 가비지 컬렉션 이전에 프로그래머가 메모리를 직접 관리하는 작업은 어렵고, 숙련되었다 하더라도 메모리 누수, 크래시의 문제를 야기할 수 있다.
  - 현대의 가비지 컬렉션은 메모리 할당/해제보다 더 빠르게 동작하며 GC가 실행되는 시간에도 속도를 높일 수 있다.
  - 가비지 컬렉터는 메모리 해제 외에 다른 작업도 수행하기 때문이다.
  - 즉, 메모리의 할당과 메모리상 객체 재정렬도 실행한다.

<br>

### 30 이름 짓기를 잘 하자 (피터 힐튼)
  - "무엇보다 필요한 것은 의미를 두고 단어를 선택하는 것이지 그 반대가 아니다. 단어를 선택하는 데 최악의 방법은 그 단어에 굴복하는 것이다." - 조지 오웰
  - 이름을 더 잘 지으면 무엇보다도 코드의 유지보수성 향상에 도움이 된다.
  - 그만큼 좋은 이름 짓기는 굉장히 어려우며 그래서 대부분 등한시한다.
  - 다행히 프로그래머는 도전을 좋아한다.
  - 피해야 할 네이밍
    - 무의미(foo), 추상적(data), 중복(data2), 약자(dat), 한 글자(d)
  - 위와 같은 네이밍은 프로그래머가 시간을 들여 코드를 읽은 후에야 코드를 작성할 수 있으므로 모든 사람의 업무 속도가 저하된다.
  - 더 나은 이름을 위한 가이드라인을 도입하자. 간편한 의미를 가진 단어를 사용하면 코드 스스로 자신의 의미를 표현할 수 있다.
    - 최대 단어: 4개, 약어는 사용 금지
    - 문제 도메인의 용어를 배우고 사용하자.
    - 단어를 스스로 만들어내지 말고 위키피디아의 토픽을 읽어보고 해당 도메인등의 단어를 사용하자.
    - 복수형은 집합 명사로 대체하자.(appointment_list 대신 calendar)
    - 더 나아가 더 짧고 간편한 이름을 지을 수 있도록 영어 어휘 능력도 키우자.
    - 엔티티 쌍의 이름은 관계의 이름으로 대체하자.(company_person은 employee, owner 등)
    - 클래스와 객체 이름을 혼합하지 말자.
      - dateCreated => created
    - 객체에는 서로 다른 이름을 지정하자.
      - Customer 타입의 변수에 customer 이름 대신 더 구체적인 이름을 사용

<br>

### 31 이봐 프레드, 해시맵 좀 전해 주겠는가? (커크 페퍼다인)
  - 프로그램을 작성할 때 중요한 부분은 어휘(vocabulary)다.
  - 우리가 사용하는 단어는 우리 손에 들려있는 문제를 생각하는 방법에도 영향을 미친다.
  - 코드 구조, 알고리즘, API 형태, 시스템이 목적에 부합하는 정도, 시스템 유지보수와 확장 용이성 등에 영향을 미친다.
  - 따라서 우리가 코드를 작성할 때 사용하는 어휘는 매우 중요하다.

<br>

### 32 널(Null)을 피하는 방법 (카를로스 오브레건)
  - 널은 실수다.
  - 널 값을 가질 수 있는 객체를 참조하면 이 객체의 메서드를 호출하기 전에 반드시 객체가 널 값을 가졌는지 확인할 것을 기억해야 한다.
  - 하지만 널 참조와 널이 아닌 참조 간에 명확한 차이가 없으므로 이 사실을 잊어버리고, 결국 NullPointerException이 발생하게 된다.
  - 이 문제를 회피할 수 있는 안전한 방법은 가능하면 다른 방법을 사용하는 것이다.
    - 변수를 널 값으로 초기화하지 말자.
    - 널 값을 리턴하지 말자.
      - Optional<T> 리턴은 코드를 더욱 명확하게 만든다.
    - 널 값 매개변수를 전달하거나 받지 말자.
    - 허용될 수 있는 널 값
      - 애트리뷰트(attribute)의 값을 다루는 클래스의 상세 구현에서 널 값을 허용할 수 있다.
    - 다음 예를 살펴보자.

```java
// 잘못된 코드
public String getEllipsifiedPageSummary(Path path) {
    String summary = null;
    Resource resource = this.resolver.resolve(path);
    if (resource.exists()) {
        ValueMap properties = resource.getProperties();
        summary = properties.get("summary");
    } else {
        summary = "";
    }
    return ellipsify(summary);
}


// 수정한 코드
public String getEllipsifiedPageSummary(Path path) {
    var summary = getPageSummary(path);
    return ellipsify(summary);
}

public String getPageSumamry(Path path) {
    var resource = this.resolver.resolve(path);
    if (!resource.exists()) {
        return "";
    }
    var properties = resource.getProperties();
    return properties.get("summary");
}
```

<br>

### 33 JVM의 크래시를 유발하는 방법 (토마스 론존)
  - 여러분의 자바 가상 머신에 크래시를 유발하는 방법을 찾아보자.(아니면 최소한 정상적으로 작동하던 코드가 갑자기 의도치 않게 멈추도록 해 보자.)
  - 더 많은 방법을 찾을수록 여러분 주변의 것을 더 잘 이해하고 실행중인 소프트웨어 시스템에서 잘못될 수 있는 부분을 알아보게 될 것이다.

<br>

### 34 지속적 전달로 반복가능성과 감사가능성 향상하기 (빌리 코란도)
  - 사람은 같은 작업을 반복하는 것에 익숙하지 않다.
  - 또한 꼼꼼한 사람이더라도 누구나 실수하기 마련이다.
  - 많은 조직이 지속적 전달을 도입해 배포 실패, 코드 전달 등의 문제를 해결하기 시작했다.
  - 지속적 전달(CD, Continuous Delivery)은 코드를 프로덕션 환경에 전달하는 단계를 자동화하는 방법이다.
  - 개발자가 변경 사항을 커밋하는 시점부터 해당 변경 사항이 프로덕션 환경에 배포될 때까지의 모든 과정에 포함된 테스트, 변경 제어, 배포 처리 등은 반드시 자동화해야 한다.
  - CD를 도입하는 주된 계기는 코드를 배포하는 데 드는 시간과 노력을 줄이기 위해서다.
  - CD는 시간과 노력의 절감, 배포 절차의 반복가능성과 감사가능성이 향상되는 장점이 있다.

<br>

### 35 자바는 자바만의 강점이 있다 (제니퍼 레이프)
  - 자바는 개발자가 무엇을 어떻게 개발하고 있는지 설명해 준다.
  - 적용 범위가 넓은 기술이다.
  - 자바는 모든 스택과 영역의 기술을 다룰 수 있게 해준다.

<br>

### 36 인라인식 사고 (패트리샤 애아스)
  - 컴퓨터는 변화하는데, RAM으로부터 데이터를 읽는 상대적인 비용이 급격히 커지고 있다는 점에 중점을 둔다.

<br><br>

### References
  - [`자바 개발자를 위한 97가지 제안`](http://www.yes24.com/Product/Goods/96036230)
