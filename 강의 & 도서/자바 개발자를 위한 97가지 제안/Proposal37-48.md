## PROPOSAL 37 ~ PROPOSAL 42

### 37 코틀린과의 상호운용 (세바스티아노 포기)
  - 최근 몇 년간 코틀린은 JVM 커뮤니티의 뜨건운 감자였다.
  - 사용하는 개발자가 점점 늘어났고, 코틀린의 장점 중 하나는 자바와의 뛰어난 **상호운용성(INTEROPERABILITY)** 이다.
  - 코틀린 코드에서 어떤 자바 코드를 호출해도 잘 동작한다.
  - 코틀린은 자바를 완벽하게 지원하지만 자바의 권장 사례를 제대로 따르지 않는다면 살짝 짜증 나는 점이 한 가지 드러난다.
  - 바로 자바에 널 값을 허용하지 않는(non-nullable) 타입이 없다는 점이다.
  - 자바 타입에 널 가능성 어노테이션을 적용하지 않으면 코틀린은 이 타입의 널 가능성을 모른다고 간주한다. 
  - 이런 타입을 플랫폼 타입(platform type) 이라고 한다.
  - 코틀린은 선택적 매개변수에 기본값을 지정하는 것을 허용한다.(자바는 X) - @JvmOverloads 어노테이션 ..
  - 정리
    - 코틀린과 자바는 거의 완전한 상호운용성을 제공한다.
    - 다른 JVM 언어보다 코틀린이 좋은 점 중 하나다.

<br>

### 38 일은 끝났어요. 그런데... (진 보야르스키)
  - 위와 같은 말은 아직 '일이 끝난게 아니잖아.' 라는 생각이 든다.
  - 아직 끝나지 않은 일을 '끝났다' 라고 말하는 것에는 크게 세 가지 문제가 있다.
  - 
#### 1. 의사소통과 명료성
  - 이상적이라면 **끝에 대한 정의** 가 있어야 한다.
  - 아직 끝나지 않은 상태는 테스트의 작성이나 문서화, 예외 상황에 대한 처리가 안 된 경우가 보통이다.
  - 아직 끝나지 않은 상태는 여러분이 더 많은 정보를 제공할 기회다.

#### 2. 인지(perception)
  - 관리자는 **끝**이라는 단어를 좋아한다.
  - 이 말은, 여러분이 다른 일을 더 하거나 다른 팀원을 도울 여력이 생겼다는 의미다.

#### 3. 부분적인 완료 따위는 없다
  - 끝이라는 것은 이분법적 상태다.
  - 즉, 끝냈거나 끝내지 못한 상태가 있을 뿐이다.
  - 부분적으로 끝낸 상태 따위는 없다.
  - 반드시 기억하자. 실제로 **끝내기 전까지는 절대 끝냈다고 말하지 말자**

<br>

### 39 자바 자격증: 기술 업계의 터치스톤 (말라 굽타)
  - 후보자의 기술 검증에 사용된다.
  - 오라클이 인증하는 자바 전문 자격증의 수요는 대단하다.
  - 이 자격증은 후보자가 정해진 요건(특정 코스, 프로젝트 완수)을 충족하면 수요된다.
  - 검증된 기술은 특정 언어를 이용한 개인의 프로그래밍 능력이나 플랫폼, 방법론, 미래의 고용주에 대한 이해도에 신뢰성을 부여한다.
  - 자바 자격증은 개인의 경력 향상에 도움이 된다.

<br>

### 40 자바는 90년대생 (벤 에번스)
  - 세상에는 사람들이 불만을 느끼는 언어와 아무도 사용하지 않는 언어, 두 가지만 존재할 뿐이다. (비야네 스트롭스트룹)
  - 2020년 시점에서, 자바는 주류이며 중도적인 언어처럼 보인다.
  - 하지만 한 가지 놓친 부분은 소프트웨어 세계가 자바의 등장을 기점으로 급진적으로 변했다는 점이다.
  - 가상 머신, 동작 자기 관리, JIT 컴파일, 가비지 컬렉션 등과 같은 굵직한 아이디어가 이제는 프로그래밍 언어의 보편적인 환경을 구성한다.

<br>

### 41 JVM 성능 관점에서의 자바 프로그래밍 (모니카 벡위드)
  - **Tip 1: 가비지에 대한 강박을 버려라**
  - **Tip 2: 벤치마크를 특정 지어 검증하라**
  - **Tip 3: 할당 크기와 비율이 중요하다**
  - **Tip 4: 적응형 JVM은 권리이자 필요다**

<br>

### 42 자바는 재밌어야 한다 (홀리 쿠민스)
  - 뭔가 재미없다고 느껴지는 이유는 그게 **낭비** 라는 것을 알기 때문이다.
  - 재미란 무엇일까?
    - 탐구 (대상에 대한 조사)
    - 놀이 (목표는 없지만 그 자체로)
    - 퍼즐 (규칙과 목표)
    - 게임 (규칙과 승자)
    - 업무 (만족감을 느낄 수 있는 목표)
  - 자바는 이 모든 것을 갖췄다.
  - 자바는 요즘 언어와 비교하면 분명 장황하다.
  - 보일러플레이트(boilerplate)는 재미는 없지만 그 중 일부는 필수로 필요하다.
  - 예를 들어 롬복(Lombok)은 게터와 세터는 물론 hashcode와 equals 메서드를 깔끔하게 자동 생성해 준다.
  - 뭘 사용하면 재밌어질까?
    - 개인적으로는 클래스 기반 코드보다 람다를 사용하는 편이 짧거나 깔끔하다는 의견에 동의하지는 않는다.
    - 하지만 람다를 사용하면 재밌다.
  - 자바 8이 출시되었을 때, 개발자는 람다를 보고 어린아이처럼 좋아했다.
    - 어떻게 동작하는지 알고 싶어 했고(탐구), 알고리즘을 함수형으로 표현하는 것에 도전했다(퍼즐)

<br>

### 43 자바의 불분명한 타입들 (벤 에번스)
  - 대체 널(null)이 무엇일까?
  - 자바를 처음 접하는 프로그래머는 널을 이해하는데 어려움을 겪는데, 다음 코드를 보면 그 내막을 알게 된다.

```java
String s = null;
Integer i = null;
Object o = null;
```

  - 따라서 null이라는 심볼은 값이어야 한다.
  - 'null이란 어떠한 참조 타입도 될 수 있는 특별한 리터럴'
  - 자바 언어 명세(JLS) 4.1절에서 다음과 같이 나와있다.

```html
자바는 특별한 null 타입을 지원한다.
이 타입은 이름을 갖지 않는 널을 표현한다.

null 타입은 이름이 없으므로 null 타입의 변수를 선언하거나 null 타입으로의 타입 변환은 불가능하다.
```

<br>

### 44 JVM은 멀티패러다임 플랫폼이다 (러셀 윈더)
  - 자바는 명령형 언어(Imperative Language)다.
  - 즉, 자바 프로그래머는 JVM이 무슨 동작을 언제 할 것인지 코드로 명령한다.
  - 하지만 컴퓨팅이란 것은 추상화의 구현에 대한 것이다.
  - 자바는 객체지향 언어로, 자바의 추상화는 객체, 메서드, 메서드 호출을 통한 **메시지의 전달** 등이다.
  - 자바를 이용해 점점 더 큰 시스템을 구현해오며 균열이 나타나기 시작했다.
  - 하지만 자바 8이 등장하면서 혁신적인 변화가 이루어졌다.
  - 메서드 참조, 람다 표현식, 인터페이스 기본 메서드(default method), 고차 함수, 암묵적 반복 등을 비롯해 많은 기능이 추가되었다.
  - 명령형 사고와 선언형(Declarative) 사고는 알고리즘을 표현하는 완전히 다른 방법이다.
  - 기본적으로 JVM은 웹서버 플러그인이었지만 서버 측 시스템을 구현하는 용도로 빠르게 전환되었다.
  - 자바 코드는 하드웨어에 독립적인 JVM 바이트코드로 컴파일되고 다시 인터프리터(interpreter)가 바이트코드를 실행했다.
  - 게다가 적시(JIT) 컴파일러 덕분에 전체 해석 모델을 JVM의 연산 모델로 바꾸지 않고도 훨씬 빠르게 실행할 수 있었다.
  - JVM을 최대한 활용하려면 문제를 해결할 올바른 프로그래밍 언어를 선택해야 한다.
  - 반드시 한 언어로 문제를 해결해야 한다는 뜻은 아니다.
  - JVM 덕분에 여러 언어(그루비, 스칼라, 코틀린 등)를 혼합해 문제를 해결할 수도 있다.

<br>

### 45 최신 동향을 파악하자 (트리샤 지)
  - 신입 첫 직장에서 애플릿(applet)이 사라지고 서블릿(servlet)이 대세가 되고 있음을 깨달었다.
  - 첫 이직 후 이제는 Vector를 사용하지 않고 ArrayList를 사용한다는 점을 깨달았다.
  - 이는 운이 좋았다.
  - 경력을 시작한 지 얼마 되지 않았음에도 필자가 참여한 자바 프로젝트에 영향을 미칠 수 있는 기술 변화를 아는 사람들을 주변에 둘 수 있었기 때문이다.
  - 사실 이는 시니어(senior) 팀 구성원의 역할이어야 했다.
  - 단순히 전달받은 사항을 지시하는 것이 아니라 문제를 해결하는 방법을 제시하고 나머지 팀이 함께 성장할 수 있도록 돕는 것 말이다.
  - 자바 프로그래머로 살아남기 위해서는 자바가 정체된 언어가 아니라는 점을 받아들여야 한다.
  - 자바는 단순히 버전만 올리는 것이 아니라 라이브러리, 프레임워크, 심지어 새로운 JVM 언어로 계속 발전하고 있다.
  - 현재 자바 버전에서 가능한 것과 앞으로 도입될 기능을 이해하는 것은 사용자에게 필요한 기능을 구현하는데 도움이 된다.
  - 즉 개발자로서 더욱 생산적이 된다는 뜻이다.
  - 자바는 이제 6개월마다 새 버전을 발표한다.
  - 계속해서 동향을 파악하면 여러분의 삶이 훨씬 더 편안해진다.

<br>

### 46 주석의 종류 (니콜리이 팔로그)
  - 자바 코드에 주석을 추가하는 상황을 생각해 보자.
  - /**, /*, // 중 어떤 키워드를 사용할 것인가?
  - 그리고 정확히 어느 위치에 이 주석을 추가할 것인가?
  - 단순 문법 문제를 떠나서 주석 의미에 따라 어떤 주석을 어디에 작성할 것인지를 결정해야 한다.
  
#### **계약은 자바독 주석으로 작성한다.**
  - 자바독 주석(/** ... */ 형식)은 클래스, 인터페이스, 필드, 메서드에만 사용하며 이들을 선언한 코드 바로 위에 작성한다.
  - 다음은 Map 인터페이스의 size() 메서드 자바독 주석이다.

```java
    /**
     * Returns the number of key-value mappings in this map.  If the
     * map contains more than {@code Integer.MAX_VALUE} elements, returns
     * {@code Integer.MAX_VALUE}.
     *
     * @return the number of key-value mappings in this map
     */
    int size();
```

  - 이 예시는 자바독 주석의 문법뿐만 아니라 그 의미도 보여준다.
  - 즉, 자바독 주석은 계약(contract)이다.
  - 이 주석으로 API 사용자에게 구현의 상세는 숨기고 타입이 추상화하는 동작을 설명한다.
  - 그와 동시에 이 메서드를 실제로 구현할 개발자에게도 어떤 동작을 구현해야 하는지를 설명한다.

#### **문맥은 블록 주석으로 작성한다.**
  - 블록(Block) 주석은 /* ... */ 로 둘러싼다.
  - 이 주석은 어느 자리에 작성해도 무관하며 개발 도구는 거의 이 주석을 무시한다.
  - 주로 클래스나 메서드의 시작 지점에서 그 구현 내용을 설명할 때 사용한다.
  - 좋은 예시는 HashMap 클래스에서 찾아볼 수 있다.

```java
/*
     * Implementation notes.
     *
     * This map usually acts as a binned (bucketed) hash table, but
     * when bins get too large, they are transformed into bins of
     * TreeNodes, each structured similarly to those in
     * java.util.TreeMap
     * [...]
*/
```

#### **이상한 점은 줄 단위 주석으로 작성한다.**
  - 줄 단위 주석은 //로 시작하므로 주석이 여러 줄인 경우 모든 줄에 반복해야 한다.
  - 주석의 위치에는 제약이 없지만, 보통 블록 바로 위에 작성한다.

#### 결론
  - 올바른 종류의 주석을 선택하자.
  - 엉뚱한 방법으로 주석을 사용하지 말자.
  - 코드가 볼썽사나우면 주석이라도 남기자!

<br>

### 47 은혜로운 flatMap (다니엘 이노호사)
  - 보편적인 프로그래머와 데이터 엔지니어는 모두 flatMap을 이해해야 한다.
  - map이나 filter와 마찬가지로 flatMap은 Stream<T>나 completableFuture<T> 처럼 '뭔가를 담는 컨테이너' 객체와 함께 사용할 수 있다.
  - 표준 라이브러리 이외로 눈을 돌려 보면 Observable<T>(RxJava)와 Flux<T>도 포함될 수 있다.
  - 여기서는 자바의 Stream<T>를 예로 들어보자.
  - map 메서드의 개념은 간단한데, 스트림이나 컬렉션 안의 모든 항목에 대해 지정한 함수를 실행하는 것이다.

```java
Stream.of(1, 2, 3, 4).map(x -> x * 2).collect(Collectors.toList());

// 결과: [2, 4, 6, 8]
```

  - 다음 코드는 어떻게 실행될까?

```java
Stream.of(1, 2, 3, 4)
    .map(x -> Stream.of(-x, x, x + 1))
    .collect(Collecotrs.toList());
    
// Stream 파이프라인의 List 객체가 리턴
```

  - 위 코드는 하나의 항목마다 여러 개의 스트림을 만들어내고 있다.
  - 이렇게 map 메서드에 여러 아이템을 리턴하는 함수를 적용해야 할 때 flatMap 메서드를 사용하면 된다.

```java
Stream.of(1, 2, 3, 4)
    .flatMap -> Stream.of(-x, x, x + 1))
    .collect(Collecotrs.toList());
    
// 결과: [-1, 1, 2, -2, 2, 3, -3, 3, 4, -4, 4, 5]
```

<br>

### 48 컬렉션을 제대로 이해하자 (니킬 나니바디카라)
  - 컬렉션은 모든 프로그래밍 언어에서 중요한 요소다.
  - 자바 언어는 JDK 1.2부터 컬렉션 프레임워크를 지원했다.
  - 많은 프로그래머가 ArrayList를 표준 컬렉션으로 사용하는데, 그 외에도 많은 유형의 컬렉션이 존재한다.
  - 컬렉션은 순서가 있는 것과 순서가 없는 것, 정렬된 것과 정렬되지 않는 것으로 나눌 수 있다.

#### List
  - List는 안정적인 인덱스를 기반으로 순서가 있는 컬렉션을 구현한 인터페이스다.
  - 리스트에는 중복된 값도 삽입할 수 있으며 아이템의 순회 순서를 예측할 수 있다.
  - List의 구현체로는 ArrayList, LinkedList가 있다.
  - 이 컬렉션의 contains 메서드는 특정 아이템을 찾을 수 있고, 리스트의 처음부터 아이템을 탐색하기 시작하므로 O(n) 연산이다.

#### Map
  - Map은 키와 값의 관계를 유지하며 유일한 키 값만 보관하는 인터페이스다.
  - 만일 맵에 같은 키와 다른 값을 추가하면 해당 키의 이전 값이 새 값으로 교체된다.
  - JDK는 HashMap, LinkedHashMap, TreeMap 등이 Map 인터페이스를 구현한다.
  - HashMap은 순서가 없는 반면, LinkedHashMap은 순서가 있다.
  - 두 클래스 모두 hashCode 메서드와 equals 메서드를 이용해 키의 유일성을 결정한다.
  - TreeMap은 정렬된 컬렉션이다. 즉 comparator나 Comparable 타입의 키를 이용해 아이템을 정렬한다.
  - TreeMap은 compareTo 메서드를 이용해 정렬 순서와 키의 유일성을 결정한다.
  - HashMap에서 키를 탐색하는 작업은 O(1) 연산이지만 값을 탐색하는 작업은 O(n) 연산이다.
    - 특정 아이템을 찾기 위한 containsKey와 containsValue 메서드를 제공한다.
    - containsKey메서드는 내부 해시테이블에서 키를 탐색한다.
    - containsValue 메서드는 컬렉션의 첫 아이템부터 모든 값을 탐색한다.

#### Set(Map과 연관)
  - Set은 유일한 아이템의 컬렉션을 정의하는 인터페이스다.(중복 X)
  - JDK에서는 키가 컬렉션의 아이템이며, 값은 널인 맵을 이용해 셋을 구현한다.
  - JDK는 HashSet(내부적으로 HashMap을 사용), LinkedHashSet(내부적으로 LinkedHashMap을 사용), TreeSet(내부적으로 TreeMap을 사용) 등을 지원한다.
  - Set 인터페이스는 특정 아이템을 탐색하기 위한 contains 메서드를 정의한다.
  - contains 메서드는 내부적으로 Map의 containsKey 메서드를 호출하므로 Set에서 아이템을 탐색하는 작업은 O(1) 연산이다.

#### 정리
  - 컬렉션은 소프트웨어 분야에서 매우 중요한 요소다.
  - 컬렉션을 효율적으로 사용하려면 각 컬렉션의 기능과 구현 방식, 그리고 최소한 아이템을 순회하는 방법 정도는 알아 둬야 한다.
  - 컬렉션은 그 활용 폭이 넓으면서도 코드의 기본적인 빌딩 블록이므로 관련 문서를 꼼꼼히 읽어보고 테스트를 작성하는 습관을 갖자.

<br><br>

### References
  - [`자바 개발자를 위한 97가지 제안`](http://www.yes24.com/Product/Goods/96036230)
