## PROPOSAL 01 ~ PROPOSAL 06

### 01 자바만으로도 충분하다 (안드레스 노라스)
  - 자바는 훌륭한 언어이며 자바 클래스 라이브러리는 범용으로 설계되었다.
  - 애플리케이션이 하나의 함수를 배포 단위로 사용하는 서버리스(serverless) 아키텍처로 이동하면서 애플리케이션 프레임워크의 장점들은 희석되고 있음
  - 기술 및 아키텍처 관점의 문제들을 처리하는 시간은 줄어들고, 프로그램의 비즈니스적 기능에 프로그래밍 노력을 더 많이 들일 수 있게 되었기 때문
  - 브루스 조이스(Bruce Joyce)는 이렇게 표현했다.
    - 우리는 때때로 바퀴를 재발명 해야한다.
    - 많은 수의 바퀴가 필요하기보다는, 많은 수의 발명가가 필요하기 때문이다.
  - 종종 자바의 클래스 라이브러리가 조금 제한적이라는 것을 느끼고 다른 뭔가를 갈구할 때도 있을 것이다.
  - 그때는 필요한 라이브러리를 사용하면 된다.
  - 유행을 좇지 말자. 이제는 단순함의 시대다.

<br>

### 02 확인 테스트 (에밀리 배쉬)

```java 
assertEquals("", functionCall())
```

  - 보통 functionCall() 함수가 문자열을 리턴하는데 어떤 값을 리턴하는지 모를때
  - 리턴값을 보면 해당 함수의 리턴되는 문자열을 알 수 있다.
  - 처음 테스트는 실패하는데, 그 후 리턴값을 복사해서 첫 번째 파라미터로 복사해 넣는다.
  - 이제 테스트를 다시 실행하면 통과하는데, 이를 필자는 "확인 테스트(approval testing)" 라고 부른다.
  - 여기서 가장 중요한 단계는 일단 출력이 올바른지 확인 후 이를 기댓값으로 사용하는 부분이다.
  - 코드 작성자가 결과를 '확인'했으므로 그 값을 테스트에 사용해도 무방하다.
  - 확인 테스트는 다음과 같은 경우에 활용할 수 있다.
    - 변경해야 할 단위 테스트가 없는 코드
    - JSON이나 XML을 리턴하는 REST API와 함수
    - 복합 객체를 리턴하는 비즈니스 로직

<br>

### 03 AsciiDoc으로 자바독 확장하기 (제임스 엘리엇)
  - 자바독은 (간혹 매끄럽지 않거나 썩 훌륭하진 않지만) 풍부한 API 문서를 생성한다는 점에서 큰 이점이 있으며 이런 트렌드는 다른 많은 언어에도 퍼져 나갔다.
  - 제임스 고슬링의 토론 내용처럼 '자바독보다는 좋은 기술 문서 작성자가 훨씬 더 나은 결과물을 만들 수 있었기'에 초기는 보수적이었으나, 점차 보편적으로 사용할 수 있는 도구의 가치가 높아짐
  - 자바독이 제공하는 API 문서 외 따라하기, 가이드, 아키텍처, 상세한 이론 설명 등으로는 자바독만으로 충분히 문서화할 수 없다.
  - 이에 좋은 대안이 아스키독(AsciiDoc)이다.
  - [`자바독 참고`](https://github.com/jiaekim123/book-effective-java/blob/main/8%EC%9E%A5/56_%EA%B3%B5%EA%B0%9C%20API%20%EC%9A%94%EC%86%8C%EC%97%90%EB%8A%94%20%ED%95%AD%EC%83%81%20%EB%AC%B8%EC%84%9C%ED%99%94%20%EC%A3%BC%EC%84%9D%EC%9D%84%20%EC%9E%91%EC%84%B1%ED%95%98%EB%9D%BC_%EA%B9%80%EC%A7%80%EC%95%A0.md)
<br>

### 04 컨테이너를 제대로 이해하자 (데이비드 델라바시)
  - 컨테이너는 사실상 런타임 패키징 메커니즘의 표준이 되어가고 있다.
  - 적정 수준의 격리화, 향상된 자원 활용, 여러 환경으로 애플리케이션을 배포할 수 있는 기능 등 여러 장점을 제공하기 때문
  - 게다가 애플리케이션을 이식할 수 있는 컨테이너 안으로 패키징하므로 애플리케이션 사이의 의존성이나 애플리케이션의 기반 플랫폼에 대한 의존성을 줄여주기도 한다.

<br>

### 05 행위를 구현하는 것은 쉽지만 상태를 관리하는 것은 어렵다 (에드슨 야나가)
  - 필자가 객체지향 프로그래밍을 처음 배울 때 접한 개념이 다형성, 상속, 캡슐화임
  - 다형성과 상속은 너무 강조되나 캡슐화는 상대적으로 주목받지 못함
  - 캡슐화를 잘 활용하면 상태와 복잡도의 증가에 순응할 수 있음
    - 상태를 내면화해서 다른 컴포넌트로부터 숨기며,
    - 안전하게 디자인된 API로만 상태를 변경할 수 있게 하는 것이 캡슐화의 기본 개념이자 복잡한 정보 시스템을 디자인하고 구현하는 핵심
  - 최소 자바 세계에서는 제대로 캡슐화된 시스템 구축에 대한 몇 가지 권장 사례가 제대로 전파되지 않고 있다.
    - 별다른 기능이 없는 클래스의 자바빈(JavaBean) 속성은 그저 게터(getter), 세터(setter)로 내부 상태를 외부로 노출하는 것이 일반적이며,
    - 이미 대중화된 자바 엔터프라이즈 아키텍처는 대부분 모든 비즈니스 로직을 서비스 클래스에 구현
  - 행위(behavior)에 의해 발생한 버그를 특정짓는 것은 비교적 '쉬운'편이다.
    - 이런 경우는 자신의 역할을 제대로 하지 않는 코드가 있기 때문
  - 반면, 코드는 제대로 동작하는 것 같은데 여전히 버그가 존재하는 경우는 훨씬 복잡하다.
    - 모순된 상태로 발생하는 버그
    - Null 값이 되어서는 안되는 속성의 값이 Null을 갖게 되어 발생하는 NullPointerException 예외
    - 반드시 양수여야 하는데 음수의 값을 갖게 되는 경우 등
  - 유효성 검사(validation) 프레임워크를 이용해 사용자가 제공하는 입력값은 확인하지만 모든 코드가 '내부 상태의 값만 변경하는' 세터를 호출할 수 있다.
  - 이러한 문제는 어떻게 해결할 수 있을까?
  - **불변성(immutability)이 그 해법 중 하나다.**
    - 객체가 불변임을 보장할 수 있고 객체를 생성하는 시점에 상태의 무결성을 검사할 수 있다면, 시스템은 절대 모순된 상태가 되지 않을 것이다.
    - 하지만 자바의 특성상 불변성을 제대로 다루지 못한다면 적어도 **가변성**을 최소화해야 한다.
    - 올바르게 구현한 팩토리 메서드와 빌더(Builder) 패턴을 이용하면 가변 상태를 최소화할 수 있다.
  - 따라서, 세터를 자동으로 생성하지 말자. 대신 세터에 대해 오래 생각해보자.
  - 세터를 추가해야 한다면, 사용 후 내부 상태를 보호하고 검증하기 위한 **변질 방지 계층**을 사용하는 것을 고려하자.

<br>

### 06 JMH로 조금 더 쉽게 벤치마킹해 보자 (마이클 헝거)
  - JVM에서의 벤치마킹, 특히 마이크로벤치마킹은 어렵다.
  - 그저 메서드 호출이나 루프가 나노초 내에 완료된다고 해서 끝낼 수 있는 것이 아니기 때문이다.
  - 웜업(warm-up), 핫스폿 컴파일레이션(HotSpot compilation), 인라이닝(Inlining), 데드코드(dead code)제거, 멀티스레딩, 측정치의 일관성 같은 코드 최적화도 고려해야 한다.
  - JMH는 올바른 마이크로벤치마크를 작성하기 위한 강력한 도구다.
  - 같은 환경에서 실행하면 결과도 비교할 수 있으므로 벤치마크 결과를 해석하는 주된 방법으로 사용해야 한다.
  - 게다가 안정적이며 반복적인 결과를 제공하므로 프로파일링 목적으로도 사용할 수 있다.
  - [`참고`](https://javabom.tistory.com/75)

<br>


### 07 아키텍처의 품질을 체계화하고 검증하는 방법의 장점 (다니엘 브라이언트) 
  - 애플리케이션의 아키텍처 품질을 코드화하고 강제하는 가장 중요한 곳은 지속적 전달(CD, Continuous Delivery) 빌드 파이프라인이다.
  - 하지만 품질 수준에 대한 논의, 팀 간 의사소통은 꾸준히 해야함
  - 숙련된 개발자가 꾸준히 코드를 보며 수정하며 이슈를 해결하더라도, 시간 압박이 생기면 내팽개쳐진다.
  - 현실적인 방법으로는 ArchUnit이나 다른 도구를 이용해 합의된 아키텍처 가이드라인과 규칙을 체계화하고 지속적 통합 빌드에 포함하는 것이다.
  - 그러면 이슈가 발생해도 엔지니어가 빠르게 확인하고 수정할 수 있다.

<br>

### 08 문제와 업무를 더 작은 단위로 나누기 (진 보야르스키)
  - 문제를 해결하는 좋은 방법은 문제를 더 작은 조각으로 나누는 것이다(분할)
  - 더 작게 나눌수록 더 좋다.
  - 일단 작은 문제 하나를 해결하면 더는 그 문제를 고민할 필요 없이 다른 문제로 넘어가면 된다.
  - 또한 커밋도 더 자주하게 되며, 롤백할 수 있는 지점도 많아진다.
  - 특별한 업무라고 생각하더라도 문제를 분할하며 작게 나누어서 보는 습관을 들이자.

<br>

### 09 다양성을 인정하는 팀 만들기 (익셀 루이즈)
  - 요즘은 지식이 넘쳐나 개인을 능가하고 더 전문화되고 있다.
  - 따라서 문제를 해결하기 위해서는 여러 팀이 서로 협업해야 한다.
  - 협업은 이제 '훌륭한' 전문가를 구분하는 가치 있는 자질 중 하나가 됐다.
  - 과거는 독립적이며 자기 주도적이면 충분히 '훌륭하다'고 할 수 있었지만, 현재는 모두가 팀의 구성원이다.
  - 그룹 구성원간의 다양성, 차이점은 더 나은 통찰을 얻을 기회이기도 하다.
  - 어떻게해야 다양성의 긍정적인 영향을 취하면서 부정적인 영향은 최소화할 수 있을까?
  - 협업의 핵심은 팀 내 **심리적 안전성**과 **신뢰**를 쌓는 것이다.
  - 서로 신뢰한다면 과제를 해결하는데 도움이 될 정보나 아이디어를 기대할 수 있다.
  - 협업의 기회가 만들어지며, 피드백을 통해 문제 상황을 벗어날 수도 있다.
  - 심리적으로 안정된 팀에서는 커뮤니케이션은 그 비용보다 장점이 더 크다고 생각하는 경향이 있다.
  - 팀의 다양성은 배경과 성향 등 두 가지 측면에서 늘일 수 있다.
  - 팀 내의 관계가 좋고 계속해서 서로 간에 신뢰를 쌓아갈 수 있다면 프로그래머로서 크게 성공하게 될 것이다.

<br>

### 10 빌드는 느려서도 안 되고 불안정해서도 안 된다 (젠 스트레이터)
  - 빌드가 느려지면 답답해지고, 다른 작업을 하다 다시 업무로 돌아올 때마다 콘텍스트 스위치를 하게 된다.
    - 콘텍스트 스위치(context switch): 여러 일을 병행하면서 그때그때 집중하는 업무가 바뀌는 현상
  - 어떠한 빌드 도구를 사용하든, 개발자 생산성을 책임지는 사람은 빌드 성능을 효율적으로 측정하고 성능이 떨어지는 원인을 추적하며 로컬 및 CI 빌드의 회귀 테스트를 실행한다.
  
<br>

### 11 아니, 내 머신에서는 잘 실행됐다니까! (벤자민 무쉬코)
  - 새로운 환경에서 코드를 빌드하다보면 다음과 같은 고민 사항이 생긴다.
    - 코드를 컴파일하려면 어떤 JDK 배포판과 버전을 사용해야 할지
    - 서로 다른 운영체제(Linux, Window)
    - 어떠한 IDE를 사용하며, 어떤 버전이 필요할지
    - 어떤 버전의 메이븐이나 빌드 도구를 설치해야 할지
  - 모든 프로젝트는 코드의 컴파일과 테스트, 실행 및 패키징에 필요한 기술적인 요구 사항과 호환되는 도구를 명확히 정의해야 한다.
  - 코드로서의 인프라스트럭처 개념에 따르면, 표준화된 버전의 빌드 도구 런타임을 프로비저닝 할 수 있는 솔루션인 **래퍼(Wrapper)** 를 제공한다.
  - 래퍼는 런타임을 다운로드하고 설치하기 위한 과정을 감싼 것이다.
  - Java의 경우 그레이들 래퍼나 메이븐 래퍼를 사용하면 된다.
  - 메이븐의 경우, 래퍼 파일을 생성하려면 메이븐 런타임을 미리 설치해야 한다.
  - 래퍼 파일은 프로젝트의 모든 개발자가 사전에 정의한 버전의 메이븐 런타임을 이용해 프로젝트를 빌드하는 데 필요한 스크립트, 설정, 절차를 표현하는 파일이다.
  - 래퍼 파일이 있으면 어떠한 머신에서도 mvnw 스크립트에 원하는 골(goal)을 지정해 손쉽게 프로젝트를 빌드할 수 있다.
  - "내 머신에서는 잘 실행됐다니까!"라고 외치던 시절은 지났다.
  - 한 번에 표준화하고 어디서든 실행하자.

```java
ex) ./mvnw clean install
```

<br>

### 12 비대한 JAR은 이제 그만 (다니엘 브라이언트)
  - 자바 애플리케이션을 하나의 커다란 JAR파일에 담아 배포하는 방법은 점점 더 보편화되고 있다.
    - 마이크로서비스 아키텍처, 데브옵스, 공개 클라우드, 컨테이너, 오케스트레이션 플랫폼 등등
  - 일부 조직에서는 모든 애플리케이션 코드를 하나의 실행 가능한 바이너리로 묶는 것을 벗어나 '날씬한 JAR' 파일을 만들기 시작했다.
  - 슬림패스트 라는 새로운 메이븐 플러그인도 만들어졌다.
    - 애플리케이션 코드를 관련된 의존성으로부터 분리해서 두 개의 결과 파일을 빌드하고 업로드한다.
    - 의존성을 별개로 빌드해서 업로드하는 것이 핵심이다.

<br><br>

### References
  - [`자바 개발자를 위한 97가지 제안`](http://www.yes24.com/Product/Goods/96036230)
