## PROPOSAL 61 ~ PROPOSAL 72

### 61 바뀐 부분만 빌드하고 나머지는 재사용하기 (젠 스트레이터)
  - 자바 개발자로서, 우리는 빌드가 완료되길 기다리느라 엄청난 시간을 보낸다.
  - 대부분은 빌드가 효율적으로 실행되지 않기 때문인데, 이는 조금만 바꾸면 개선을 이룰 수 있다.
  - 예를 들어, 전체 프로젝트 대신 서브모듈만 실행하고 빌드를 실행할 때마다 클린하지 않는 것이다.
  - 이보다 더 큰 효율 개선을 이루고 싶다면 그레이들, 메이븐, 바젤 같은 빌드 도구가 제공하는 빌드 캐싱(build caching) 기능을 활용하면 된다.
  - 이는 빌드 단계 중 매번 같은 결과를 생산하는 단계를 캐시하는 것이다.

<br>

### 62 오픈소스 프로젝트는 마법이 아니다 (젠 스트레이터)
  - 현대의 웹에서는 참조 가이드와 소스코드를 찾아 그 기술이 어떻게 동작하는지 알아내기가 그 어느 때보다 쉽다.
  - 많은 오픈소스 프로젝트가 웹사이트에서 문서, 참조 가이드, 버그 트래커, 심지어 소스 코드로의 링크까지 제공한다.
  - 그 프로젝트를 시험해 보고 싶다면 가이드와 튜토리얼부터 시작하면 된다.
  - 기본 문법과 데이터 구조를 학습한 후에는 자신의 프로젝트에 도입해 보면 된다.
  - 그러면 금세 기대하지 않았던 동작이나 버그와 마주칠 것인데, 이는 당연한 문제이다.
  - 우리가 몸담고 있는 세계가 그런 세계인 것이다.
  - 문제에 봉착한 또 다른 사람이 없는지 확인해보자.

<br>

### 63 Optional은 규칙을 위반하는 모나드지만 좋은 타입이다 (니콜라이 팔로그)
  - 대부분 프로그래밍 언어에서 '비었거나 그렇지 않은 타입'은 잘 동작하는 모나드(monad)다.
#### 모나드 정의
  - 모나드는 세 가지로 정의한다.
  - Optional의 관점에서 이 세가지를 살펴보면 다음과 같다.
    - Optional<T> 타입 객체
    - 값 T를 Optional<T>로 감싸는 ofNullable(T) 메서드
    - Optional로 감싼 값에 지정한 함수를 적용하는 flatMap(Function<T, Optional<U>>) 메서드
// ...
  - Optional은 모나드를 왜 위반하게 되었을까?
    - 널 안정성이 훨씬 더 중요하기 때문

<br>

### 64 기본 접근 한정자를 가진 기능 단위 패키지 (마르코 비렌)
  - 많은 비즈니스 애플리케이션은 3계층 아키텍처를 채택한다.
  - 뷰(View), 비즈니스(Business), 데이터(Data) 계층을 말하며 모든 모델 객체를 이 3계층이 공유한다.
  - 자바 언어는 접근 한정자(access modifier)라는 메커니즘을 제공한다.
  - 클래스, 필드, 메서드 등에 접근 한정자를 명시적으로 선언하지 않으면 기본 접근 한정자를 사용한다.
  - 접근 제어 한정자 없이 선언한 변수나 메서드는 같은 패키지에 있는 클래스에서만 사용할 수 있다.
  - 이를 **패키지 비공개(package-private)** 한정자라고 한다.
  - 접근 보호 메커니즘을 활용하려면 코드는 반드시 기능 **단위 패키지(package-by-fetaure)** 구조로 정리해야 한다.

<br>

### 65 프로덕션 환경은 지구상에서 가장 행복한 곳이다 (조시 롱)
  - 프로덕션 환경으로의 여행을 최대한 즐길 수 있는 팁을 공개한다.
  - **지속적 전달 고속도로를 타자**
    - 지속적 전달을 통해 최신 git 커밋의 수정 사항을 프로덕션 환경으로 빠르고 일관성 있게 전달할 수 있다.
    - 지속적 전달 파이프라인을 갖추면 클릭 한 번으로 코드를 개발자로부터 필요한 모든 단계를 거쳐 배포에 이르게 할 수 있다.
    - Travi CI나 Jenkins같은 지속적 통합 도구가 도움이 되겠지만 프로덕션 환경에서 최대한 많은 정보를 캐내도록 하자.
  - **프로덕션 환경에서는 예상외의 일이 일어날 수 있다.**
    - 단단히 대비하자!
    - 서비스는 언제든 실패할 수 있다.
    - 서킷 브레이커를 이용해 명시적으로 장애 모드를 정의하고 장애를 격리하자.
    - 스프링 클라우드는 반응형(reactive) 및 비반응형 서킷을 모두 지원하는 스프링 클라우드 서킷 브레이커를 추상화한다.
  - **프로덕션 환경에서는 누구도 애플리케이션의 문제를 눈치채지 못한다**
    - 처음부터 관측가능성을 염두에 두자.
    - 프로덕션 환경은 바쁜 곳이다.
    - 수요가 늘어나면 확장하자.
  - **코드가 스레드를 독점하지 못 하도록 하자**
    - 스레드는 무지하게 비싸다.
    - 프로젝트 리액터, 스프링 웹펄럭스, RxJava 등이 지원하는 반응형 프로그래밍 같은 것을 배워야 한다.
    - 반응형 프로그래밍의 원리를 이해하면 자연스럽게 코틀린의 코루틴 같은 것을 활용하게 된다.
  - **자율성이 성공의 핵심이다**
  - **애플리케이션의 90%는 지루하다**

<br>

### 66 좋은 단위 테스트에 기반한 프로그래밍 (케블린 헤니)
  - 단위 테스트를 작성한다면 다행이다.
  - 좋은 테스트의 의미는 무엇일까? 어려운 문제지만 그 해답을 구할 가치가 있다.
  - 코드를 읽는 사람에게 지금 보는 코드가 테스트 코드임을 알려주는 것보다 정확히 뭘 테스트하는지 알려줘야 한다.
  - 어떤 동작, 속성, 기능 등을 테스트하는지 알려줘야 한다.
  - addItem이라는 메서드를 테스트한다고 테스트 이름을 addItemIsOk라고 짓지 말자.
  - 이런 이름이야 말로 테스트 스멜(권장하지 않는 방법)이다.
  - 테스트의 목적이 '이 코드가 동작하는지' 테스트하는 것이 목적이라면 테스트의 목적 중 절반만 달성한 것이다.
  - 테스트를 작성한다는 것은 동작하는 코드의 의미를 생각해 볼 기회이므로 additionOnItemWithUniqueKeyIsRetained나 additionOfItemWithExistingKeyFails 같은 이름이 적합하다.
  - 하지만 이렇게 긴 테스트의 이름은 프로덕션 환경에 배포할 코드도 아니므로 언더스코어(_) 문자를 이용해 가독성을 개선하는 것이 좋다.
  - 이름이 너무 길면 카멜케이스도 결국 알아보기 힘들다.
  - addition_Of_Item_With_Existing_Key_Fails 가 좋겠다.
  - 좋은 단위 테스트를 작성하려면 실패의 의미가 명확해야 한다.
  - 즉, 코드가 동작하지 않음을 의미해야 한다.
  - 너무 쓸데없는 테스트를 작성하는 것도 주의해야 한다.
  - 테스트의 품질 이야기가 나왔으니 말인데, 많은 개발자가 arrange-act-assert나 given-when-tehn 이라는 3단계로 테스트를 작성한다.
  - 이 점을 명심하면 테스트가 무엇을 위한 것인지를 표현하는데 더 집중할 수 있다.
  - 응집력을 높이고 다른 테스트도 제안하면서 좋은 이름을 지정하자.

<br>

### 67 OpenJDK 소스 코드를 매일 읽는 이유 (하인츠 M. 카부츠)
  - OpenJDK는 수백만 줄의 자바 코드로 만들어졌다.
  - 그래서인지 거의 모든 클래스가 '클린 코드' 가이드라인을 위반하고 있다.
  - 실세계는 매우 복잡하다.
  - 다음은 ArrayList에 중첩된 Spliterator 클래스의 메서드 코드를 발췌한 것이다.

```java
public Spliterator<E> trySplit() {
    int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;
    return (lo >= mid) ? null : // divide range in half unless too small
            new RandomAccessSpliterator<>(this, lo, index = mid);          
```

  - 이 메서드는 분명 '클린 코드' 가이드라인에 위배된다.
  - final 키워드를 좋아하는 사람이라면 hi, mid를 final로 선언해야 한다고 불평할 것이다.
  - OpenJDK 소스 코드에서는 지역 변수를 final로 선언하지 않는 사례가 점점 늘고 있다.
  - (lo + hi) >>> 1 같이 자주 사용하지 않는 표현을 사용했을까?
  - 그냥 (lo + hi) / 2 라고 표현하면 안됐을까? (두 코드는 완전히 같지는 않다.)
  - 우리는 다른 스타일의 코드를 읽는 것에 익숙해져야 한다.
  - 그러기 위해 OpenJDK 소스 코드를 읽어보길 권한다.
  - java.util.classes, java.io 패키지의 코드를 비롯해 많은 코드를 읽어보길 바란다.

<br>

### 68 내부를 제대로 들여다보기 (라파엘 베네비지스)
  - 자바는 완전한 플랫폼이므로 그만한 대우를 받아야 한다.
  - 자바의 문법에 매우 익숙한 수백 명의 개발자를 만나봤는데, 이들은 람다와 스트림을 이해하고 있으며 String부터 nio에 이르기까지 모든 API를 꿰고 있다.
  - 하지만 다음 사항을 이해하면 더욱 완전한 전문가가 될 수 있다.
#### 가비지 컬렉션 알고리즘
  - JVM의 GC는 첫 버전 이후로 많은 개선을 이루었다.
  - JVM은 실행 중인 환경을 알아낸 후 최적의 매개변수를 자동으로 조정하도록 디자인되었다.
  - 따라서 이 부분이 어떻게 동작하는지 이해하면 JVM의 성능을 더욱 개선할 수 있다.
#### JVM 프로파일러
  - JVM 튜닝은 그냥 감으로 할 수 있는 일이 아니다.
  - 뭔가를 바꾸기 전에 애플리케이션이 어떻게 동작하는지를 이해해야 한다.
  - 프로파일러 데이터에 연결하고 해석하는 방법을 습득하면 JVM이 더 나은 성능을 발휘하도록 튜닝하거나 메모리 누수를 찾거나 또는 왜 특정 메서드의 실행이 느린지를 이해할 수 있다.
#### 문자 인코딩
  - OS마다 서로 다른 방식으로 문자를 인코딩(Encoding)한다.
  - 이 차이점을 이해하면 애플리케이션이 이상한 문자를 출력하는 상황을 방지할 수 있다.
#### TCP/IP 네트워킹
  - 클라우드 네이티브 애플리케이션은 기본적으로 분산 시스템이다.
  - 클라우드 세계에서는 인터넷, 네트워크, 라우트 테이블, 지연 응답(latency), 방화벽 등 TCP/IP 네트워킹과 관련된 모든 것이 중요하다.
#### HTTP 프로토콜
  - 클라이언트가 브라우저라면 HTTP 1.1과 2.0의 동작 원리를 이해하면 보다 나은 애플리케이션을 디자인 할 수 있다.
  - HTTP 세션에 데이터를 저장했을 때 어떤 결과로 이어질 수 있는지 이해하는 것은 분명히 도움이 된다.
#### 개발 환경에서 SQL 출력 활성화하기
  - SQL 출력을 활성화하면 이상한 SQL 호출이 일어나기 전에 어떤 명령이 데이터베이스로 보내지는지 미리 확인할 수 있다.
#### 쿼리 패치 크기
  - 대부분 JPA/하이버네이트 구현체의 기본 패치 크기는 1이다.
  - 즉 1천 개의 엔티티를 데이터베이스에서 가져오는 쿼리를 실행하면 1,000개의 SQL 명령이 실행된다는 뜻이다.
  - 패치 크기를 조정하면 SQL 명령의 수를 줄일 수 있다.
#### 일대다와 다대일 관계
  - 일대다(OneToMany) 관계는 기본적으로 지연 로드(lazy loaded)지만 일부 개발자는 엔티티의 컬렉션을 리턴하기 전에 수동으로 초기화하거나, 또는 다른 엔티티까지 같이 로드하기 위해 이 관계를 변경하는 실수를 범하곤 한다.
  - 하지만 미리 로드하는 엔티티가 다대일(ManyToOne) 관계를 가질 수도 있어서 데이터베이스의 거의 모든 테이블/엔티티를 로드하게 되는 경우도 있으므로 주의해야 한다.
#### 요약하자면, 끌려다니지 말고 제대로 제어하자 !!

<br>

### 69 자바의 재탄생 (샌더 맥)
  - 자바는 한물갔다는 소리를 많이 들어왔다.
  - 하지만 자바는 백엔드 개발에 엄청난 족적을 남겼으며 대부분 기업이 자바로 시스템을 개발하고 있다.
  - 자바는 루비와 자바스크립트 같은 동적 언어가 발전하는 동안 거의 변화가 없었는데, 3~4년에 한 번 메이저 버전을 릴리스했다.
  - 하지만 2017년, 모든 것이 변했다.
  - (자바를 보유한) 오라클이 자바 플랫폼을 1년에 2회 릴리스하기로 발표한 것이다.
  - 2017년 말에 발표된 자바 9을 끝으로 더는 새로운 버전을 오래 기다릴 필요가 없게 됐다.
  - 자바 9 이후부터는 정확히 매년 3월과 9월에 자바의 새로운 메이저 버전이 릴리스 된다.
  - 자바 9에서는 플랫폼이 완전히 모듈화되었다.
  - 플랫폼을 구성하는 부분이 이제 각자의 모듈로 나뉘었으며 명시적으로 다른 모듈에 의존성을 갖는다.
  - 길고 예측할 수 없는 릴리스 주기에서 정기적이며 날짜에 기반한 릴리스로 바꾼다는 것은 자바 팀에게는 큰 성과다.
  - 개발자 커뮤니티가 이런 변경에 적응하려면 시간이 필요하다.

<br>

### 70 클로저에 의한 JVM의 재발견 (제임스 엘리엇)
  - 클로저(Clojure)는 강력한 동시성을 함수형으로 제공하며 불변(immutable) 데이터를 효율적으로 변환하는 언어였다.
  - 우리에게 익숙한 JVM상에서 동작하며 거대한 자바 라이브러리 생태계도 무리 없이 활용할 수 있었다.
  - 우리는 REPL(Read-Eval-Print Loop) 위주로 작업하는 것의 장점을 발견할 수 있었다.
    - 변경 사항을 테스트하기 위해 다시 빌드하거나 애플리케이션을 다시 실행할 필요가 없다.
    - 실행 중인 시스템을 확인하고 여러 가지를 즉각적으로 실행해 볼 수 있다.
    - 발상(idea)를 점진적으로 구축하고 재정의할 수 있다.
  - 필자는 자바 개발자라면 반드시 클로저를 심각하게 고려하길 권한다.
  - 그리고 JVM 기반의 삶을 어떻게 바꿀 수 있는지 확인하길 바란다.

<br>

### 71 불리언 값은 열거자로 리팩토링하자 (피터 힐튼)
  - 아마도 여러분은 코드에 '매직 넘버(magic number)'를 사용하지 않을 것이다.
  - 같은 이유로 매직 불리언도 사용하면 안된다!
  - 불리언 리터럴은 하드코딩한 숫자보다 더 좋지 않다!!
  - 코드에 42라는 숫자를 하드코딩하는 것은 흔한 일이겠지만 false는 무엇이든 될 수 있고, 무엇이든 false가 될 수 있다.
  - 2개의 변수가 모두 true라고 한다면 우연히 그렇게 된 것인지, 아니면 두 변수가 같은 이유로 'true'가 됐고 함께 바뀌어야 하는지 알 수 없다.
  - 덕분에 코드를 읽기가 어려워질뿐더러 코드를 잘못 읽었을 때 버그를 유발한다.
  - 42를 ASICC_ASTERISK나 EVERYTHING 같은 상수로 리팩토링하면 코드의 가독성이 높아진다.
  - 그러므로 true 값도 상수로 리팩토링 해야한다.
  - 예를들어 Product 클래스에서 true 대신 AVAILABLE이라는 상수를 사용하면 훨씬 읽기 편하다.
  - 서로 연관된 두 불리언 필드를 자바의 열거자 타입(enum type)을 이용해 리팩토링해보자.

```java
enum ProductAvailability {
    AVAILABLE, OUT_OF_STOCK, DISCONTINUED, BANNED
}
```

  - 열거자 타입이 좋은 이유는 더 많은 이름을 추가할 수 있기 때문이다.
  - 게다가 실제로는 AVAILABLE 같은 다른 값을 의미하는 true보다 훨씬 읽기도 좋다.
  - 또한 열거자 타입은 귀찮아서 리팩토링하지 않는다는 것이 이유가 되지 않을 정도로 편리하다.

<br>

### 72 속독을 위한 리팩토링 (벤자민 무스칼라)
  - 이번 장에서는 코드를 읽는 데 특히 도움이 되는 훑어보기(skimming), 메타 가이딩(meta guiding), 시각적 고정(visual fixation) 등 세 가지 영역을 설명하겠다.
  - 메타 가이딩은 속독을 위한 또 다른 기법이다.
  - 책을 단어 단위로 읽는 것이 아니라 한줄을 한 번에 읽는 것이다.

```java
List<String> items = new ArrayList<>(zeros);
list.add("one");
list.add("two");
list.add("three");
```
  
  - 이 리스트에는 마치 3개처럼 보이겠지만 사실은 4개, 혹은 그 이상이 저장되었을 수 있다.
  - 이런, 여러분도 zero 매개변수를 눈치채지 못했는가?
  - 사실 코드의 구조는 코드를 읽는 사람을 도와줘야 한다.
  - 이 코드를 다음과 같이 리팩토링하면 읽는 사람이 중요한 정보를 놓치지 않도록 이끌 수 있다.

```java
List<String> items = new ArrayList<>();
list.addAll(zeros);
list.add("one");
list.add("two");
list.add("three");
```

  - 다음에 코드를 작성할 때는 스스로 빨리 읽을 수 있는지 확인해 보자.
  - 그리고 시각적 고정과 메타 가이딩을 염두에 두고 코드를 작성하자.
  - 관련 정보를 눈으로 확인할 수 있는 논리적인 느낌을 줄 수 있도록 구조를 갖추자.
    

