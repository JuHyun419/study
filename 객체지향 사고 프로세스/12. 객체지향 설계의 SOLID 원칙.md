## 12. 객체지향 설계의 SOLID 원칙
  - 실제 세계를 모델링할 수 있는게 객체지향 프로그래밍의 주요 장점
  - 로버트 마틴에 따르면, 객체지향이란 핵심 의존성들을 역전시킴으로써 경직된 코드나 취약한 코드 및 재사용이 불가능한 코드가 되지 않게 하는 식으로 의존체들을 관리하는 일이라고 함
  - '밥 삼촌'이라고 불리는 로버트 마틴은 재사용할 수 없는 코드를 설명하기 위해 다음 세 가지 용어를 정의한다
    - **경직성(rigidity)**: 프로그램의 한 부분을 변경하면 다른 부분까지 변경해야 하는 경우
    - **취약성(fragility)**: 관련이 없는 곳에서 오류가 발생하는 경우
    - **부동성(immobility)**: 코드를 원래 맥락에서 벗어나 재사용할 수 없는 경우
  - 위와 같은 문제들을 해결하고 목표를 달성하기 위해 SOLID가 도입되었다.
    - **SRP(Single Responsibility Principle): 단일 책임 원칙**
    - **OCP(Open/Close Principle): 개방/폐쇄 원칙**
    - **LSP(Liskov Substitution Principle): 리스코프 대체 원칙**
    - **ISP(Interface Segregation Principle): 인터페이스 분리 원칙**
    - **DIP(Dependency Inversion Principle): 의존성 역전 원칙**

<br>

## 1) SRP: 단일 책임 원칙
  - 단일 책임 원칙에 따르면, 클래스를 변경해야 하는 이유는 단 한가지여야 한다.
  - 클래스가 설명하는 글에 '그리고'라는 단어가 포함되면 SRP가 깨질 수 있다.
  - 즉, 모든 모듈이나 클래스는 소프트웨어가 제공하는 기능의 단일 부분에 대해서만 책임을 져야 하며, 그 책임을 클래스로 완전히 캡슐화 해야한다.
  
<br>

## 2) OCP: 개방/폐쇄 원칙
  - 클래스를 수정하지 않고 클래스의 행위를 확장할 수 있어야 한다.

<br>

## 3) LSP: 리스코프 대체 원칙
  - 리스코프 대체 원칙에 따르면 부모 클래스의 인스턴스를 해당 자식 클래스 중 하나의 인스턴스로 교체할 수 있게 설계해야 한다.
  - 부모 클래스가 무언가를 할 수 있다면 자식 클래스도 그것을 할 수 있어야 한다.
  - 예를 들어 Car라는 클래스에서 Excel() 이라는 행위가 있다면, 이 행위는 전진하는 행위이므로 속도가 +여야 한다.
  - 하지만 상속받는 BMWCar 라는 클래스에서 Excel()이라는 행위가 속도가 -이라면 절대 안되므로 리스코프 대체 원칙에 어긋난다.
  
<br>

## 4) ISP: 인터페이스 분리 원칙
  - 인터페이스 분리 원칙에 따르면 몇 개의 큰 인터페이스가 있는 편보다는 작은 인터페이스가 많은 편이 바람직하다.
  
<br>

## 5) DIP: 의존성 역전 원칙
  - 의존성 역전 원칙은 코드가 추상화에 의존해야 한다고 명시하고 있다.
  - 종종 의존성 역전(Dependency Inversion)과 의존성 주입(Dependency Injection)이라는 용어를 논의할 때 이해해야 할 핵심 용어가 있다.
    - 의존성 역전: 의존체들을 역전시키는 원칙
    - 의존성 주입: 의존체들을 역전시키는 행위
    - 생성자 주입: 생성자를 통해 의존성 주입을 수행
    - 파라미터 주입: Setter와 같은 메서드의 파라미터를 통해 의존성 주입을 수행
  - 의존성 역전의 목표는 구상적인 것에 결합하기보다는 추상적인 것에 결합하는 것
  - 의존성 역전 원칙의 목표 중 하나는 컴파일타임이 아니라 **런타임**에 객체를 선택하는 것
  
<br>

## 결론
  - SOLID 원칙은 오늘날 사용되는 가장 영향력 있는 객체지향 지침 중 하나다.
  - 이러한 원칙들이 기본적으로 객체지향적인 캡슐화, 상속, 다형석, 합성과 어떤 식으로 관련되어 있느냐가 흥미로운 점이다.
