## 가상 메모리(Virtual Memory)
> 실제 메모리 크기와 상관 없이 메모리를 이용할 수 있도록 가상의 메모리 주소를 사용하는 방식 
> 
> 가상 메모리의 핵심은 필요한 부분만 메모리에 적재(부분적으로) 하는 것

### 가상 메모리는 왜 필요할까?
- 프로그램의 메모리 회수를 위해
- 물리 메모리 크기의 한계를 극복하기 위해

#### 프로그램의 메모리 회수를 위해
![image](https://user-images.githubusercontent.com/50076031/167435476-435473f2-bea0-4c08-b5ab-555edda62e85.png)

<br>

![image](https://user-images.githubusercontent.com/50076031/167436004-507d6136-70a6-437d-a40a-e689192c7985.png)
- 프로그램이 비정상적으로 종료되었을 때 운영체제가 메모리를 회수할 수 있는 방법이 없었음
- 즉, 어플리케이션 하나가 문제가 발생했을 때 전체 시스템이 문제가 발생할 수 있는 상황이 발생할 수 있음
- 따라서 해당 문제를 해결하려면 운영체제 자체를 재부팅을 하는 등의 불편함이 존재 
- 요약하자면, **어플리케이션 하나의 문제로인해 운영체제 전체가 장애가 나는 문제를 해결하기 위해**

<br>

#### 물리 메모리 크기의 한계를 극복하기 위해
- 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기에 한계가 존재하고, 또한 메모리는 비싼 영역
- 특정 어플리케이션 수행 시 100MB 용량이 필요하다고 가정해보자.
  - 가상 메모리가 존재하지 않는다면 운영체제의 메모리는 어플리케이션을 수행하기 위해 최소 100MB가 필요함
  - 그보다 모자라면 메모리 부족으로 오류가 발생한다.
  - 즉, 한 시스템에서 수행되는 가장 큰 어플리케이션 용량보다 메모리가 더 커야한다.
  - 만약 두 개 이상의 프로그램이 수행되는 멀티태스킹이라면, 더 필요하게 된다.
- 가상 메모리의 핵심은 어플리케이션 실행에 필요한 부분만 메모리에 적재를 하는 것
- 따라서 적은 메모리에서 많은 프로그램을 실행시키는 방법에 대한 문제로 인해 나오게 된 것 기술이 **가상메모리**

### 가상 메모리의 기본 아이디어
- 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔주면 된다.
  - 가상 주소(virtual address): 프로세스가 참조하는 주소
  - 물리 주소(physical address): 실제 메모리 주소
- MMU(Memory Management Unit)
  - CPU가 메모리에 접근하는 것을 관리하는 컴퓨터의 하드웨어 부품
  - 가상 메모리 주소를 실제 메모리 주소로 변환 및 메모리 보호, 캐시 관리 등의 역할을 담당
  - CPU에 코드 실행 시, 가상 주소 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

### 가상 메모리와 MMU(Memory Management Unit)
- CPU는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리에 접근
  ![image](https://user-images.githubusercontent.com/50076031/164965846-a1ee083b-6853-4a02-b325-064b6d4cc3e2.png)

### 가상 메모리 활용
- 1차 메모리(주 메모리, RAM)
  - 정보 저장 및 검색에 CPU가 직접 접근하는 메모리
  - 휘발성 메모리로 전원이 꺼지면 데이터가 손실
- 2차 메모리(보조 기억장치, HDD)
  - CPU가 직접 접근할 수 없고, 전원이 꺼진 후에도 데이터를 보유하는 영구 저장 장치
  - CPU는 I/O를 통해 이러한 장치에 접근하고, 접근하기 전 데이터가 먼저 2차 메모리 -> 1차 메모리로 전송

![image](https://user-images.githubusercontent.com/50076031/168624875-2c5ecfd5-3f68-4b12-b115-ec41095b5375.png)

<br>

![image](https://user-images.githubusercontent.com/50076031/168625919-fce39112-5312-47e4-98f7-cd5883853d7f.png)

<br>

![image](https://user-images.githubusercontent.com/50076031/168626408-211474d4-0ba3-4f0c-aee5-0034806bf742.png)

- 프로세스를 사용하거나 사용하지 않을때 주기억장치 <-> 보조기억장치로 swap in & swap out 해주는 게 가상메모리의 역할

### 페이징 시스템(Paging System)
- 가상 메모리 -> 프로그램에 필요한 부분만 실제 메모리에 올려놓고 사용
  - 여기서, 메모리에 어느정도의 사이즈로 관리를 할 지를 나타내는게 **페이징 시스템**
- 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
- 가상 메모리 시스템은 4KB의 Page 단위로 관리
  - 페이징이란, 고정 크기로 분할된 페이지(page)를 통해 가상 메모리를 관리하는 기법

![image](https://user-images.githubusercontent.com/50076031/168616763-bf6291cd-1741-40c0-8741-1b3feb63e189.png) 
- CPU -> 가상 주소 접근 -> 가상 주소는 페이지 번호를 확인하고 -> 페이지 테이블을 통해 물리 주소를 찾는다.
- 페이지 테이블은 운영체제가 관리하고, MMU가 접근해서 읽는다.
- 페이지 테이블: 가상 주소와 물리 메모리 주소의 매핑 테이블

### 참조
- https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=kywpcm&logNo=30168638211
- https://fastcampus.co.kr/
- https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B4%80%EB%A6%AC_%EC%9E%A5%EC%B9%98
- https://www.youtube.com/watch?v=rhH_-WffWQA&t=317s