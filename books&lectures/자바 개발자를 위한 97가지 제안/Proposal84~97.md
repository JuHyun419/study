## PROPOSAL 84 ~ PROPOSAL 97

### 84 마이크로서비스 아키텍처의 트레이드 오프 (케니 바타니)
  - 최적의 소프웨어 아키텍처란 최소한의 비용으로 변경할 수 있는 극강의 유연성을 가진 것이다.
  - 여기서 비용이란, 인프라스트럭처의 운영 비용 외에 소프트웨어의 디자인과 구현을 입증하는 어떤 품질로 측정할 수 있는 것이다.
  - 마이크로서비스의 주요 문제 중 하나는 포괄적인 하나의 정의가 없다는 점이다.
  - 게다가 마이크로서비스는 서비스 아키텍처를 전달하기 위한 여러 제약에 기반을 둔 개념과 발상의 집합이다.
  - 마이크로서비스, 또는 여러분이 작성하는 소프트웨어의 일부는 선택의 기록이다.
  - 그리고 이 기록은 오늘 여러분이 새로운 선택을 하는 능력에 영향을 준다.
  - 마이크로서비스를 한 가지로 정의할 수는 없을지 몰라도 대부분 다음과 같은 공통점을 갖는다.
    - 독립적인 배포가 가능하다.
    - 비즈니스 역량을 중심으로 체계화된다.
    - 서비스별로 독립된 데이터베이스를 갖는다.
    - 한 팀이 한 애플리케이션을 담당한다.
    - API 우선 방식을 취한다.
    - 지속해서 전달된다.
  - 다음 내용은 마이크로서비스에 의존성을 추가하는 결정을 내릴 때 마주하게 될 트레이드 오프를 나열한 것이다.
    - 가용성: 내 시스템은 사용자에게 어느 정도의 가용성을 제공하는가?
    - 성능: 내 시스템의 전반적인 성능은 어느 정도인가?
    - 일관성: 내 시스템은 일관성과 관련해 어떤 것을 보장할 수 있는가?
    - 속도: 코드를 한 줄 바꿨을 때 프로덕션 환경에 얼마나 빨리 배포할 수 있는가?
    - 결합성(composability): 아키텍처와 코드베이스에서 복제하지 않고 공유할 수 있는 부분이 몇 %인가?
    - 연산: 부하가 피크(peak) 상태일 때 시스템의 연산 비용은 얼마인가?
    - 확장성: 부하의 피크가 계속 증가할 때 용량을 확장하기 위한 비용은 어느 정도인가?
    - 수익성: 내 팀에 개발자를 추가했을 때의 평균 감소 한계 수익은 얼마인가?
    - 파티션 내구성: 네트워크 파티션에서 장애나 응답 지연이 발생하면 내 애플리케이션이 연쇄 장애(cascading failure)의 영향을 받거나 유발할 것인가?
  - 각각의 질문은 서로 다른 질문과 연관이 있다는 것을 알게 될 것이다.

<br>

### 85 예외를 확인하지 말자(??) (케블린 헤니)
  - 자바 코드의 장점은 이해하기 쉽다는 점이고, 자바의 확인된 예외 모델도 이렇게 잘 정리된 개념 중 하나이다.
  - 확인된 예외(checked exception)란, 메서드 안에서 처리하지 않으면 반드시 메서드의 throws 절에 추가해야 하는 예외를 말한다.
  - throws 절에는 Throwable 인터페이스를 구현하는 클래스라면 어떤 것이든 나열할 수 있지만, 확인된 예외임에도 처리하지 않는(RuntimeException, Error 클래스를 상속하지 않는) 예외는 반드시 나열해야 한다.
  - 확인된 예외의 의도는 메서드가 성공적으로 실행될 때의 입력과 출력의 타입이 중요한 만큼, 메서드가 실패하는 경우도 예외의 타입으로 표현해서 두 가지 시나리오 모두 같은 수준의 타입 중요성을 갖도록 하자는 것이다.

```html
C#은 자바와 같은 예외 명세를 요구하지도 않고 허용하지도 않는다.
예외 명세는 프로그램의 크기가 작을 때는 개발자의 생산성과 코드의 품질을 모두 향상할 수 있지만, 대규모 소프트웨어 프로젝트에서는 그렇지 못했다.
오히려 생산성이 떨어지고 코드 품질의 향상은 극히 미미하거나 전혀 이루어지지 않았다.
```

  - 확인된 예외는 문법적으로 부담이 될 뿐이다.
  - 하지만 실질적인 문제는 단순히 프로그래머의 학습을 요구하거나 구문이 장황해지는 문제가 아니다.
  - 프레임워크 개발이나 확장 가능한 코드의 측면에서 볼 때 확인된 예외는 애당초 결함이었던 것이다.
  - 인터페이스는 안정적으로 정의하기도 어렵고 나중에 개선하기도 어렵다.
  - 다른 개발자가 자신의 애플리케이션에 여러분이 작성한 코드를 사용한다고 생각해 보자.
  - 이 개발자는 자신이 어떤 예외를 던질지 알 수도 있지만 여러분은 그 개발자가 어떤 예외를 던질지 알지도 못하고 알 필요도 없다.
  - 여러분의 코드는 그저 예외가 다른 개발자의 코드로 전달되어 그 애플리케이션 코드 예외 핸들러까지 도착하도록 하기만 하면 된다.
  - 제어의 역전(IoC)을 제대로 지원하려면 예외 투명성이 필요하다.

<br>

### 86 컨테이너로 통합 테스트의 숨겨진 가능성을 끌어내자 (케빈 위텍)
  - 대부분 자바 개발자는 어떤 형태로든 경력의 어느 한 시점에서 테스트 피라미드와 마주하게 된다.
  - 테스트 피라미드라는 비유는 다양하지만, 일반적으로는 상당한 양의 단위 테스트가 기반이 된다.
  - 그리고 그 위에 그보다 작은 양의 통합 테스트가 자리하며 꼭대기에는 더 작은 크기의 종단간 UI 테스트가 자리한다.
  - 이 도형은 서로 다른 테스트 클래스의 이상적인 최적의 비율을 제시한다.
  - 완전한 개발 환경을 갖춘 가상 머신을 사용하거나 혹은 가상 머신을 이용해 통합 테스트를 실행하는 데 필요한 외부 의존성을 실행하고 관리할 수 있다.
  - 하지만 대부분 가상 머신 구현체는 오버헤드를 가지고 있으므로 가상 머신을 사용한다는 것은 개발자의 워크스테이션에 상당한 부하와 리소스 소모를 유발한다.
  - 또한 테스트를 실행하기 위해 필요한 환경을 일시적으로 셋업하기 위한 가상 머신의 시작과 생성 시간은 너무 길다.
  - 반면, 사용자 친화적인 컨테이너 기술의 장점 덕분에 새로운 테스트 패러다임이 등장했다.
  - 내 생각에 우리가 달성하기 위해 노력해야 하는 목표는 테스트 환경의 셋업과 구성을 테스트 실행의 주요부분, 심지어 테스트 코드와 같은 수준으로 중요하게 취급하는 것이다.

<br>

### 87 퍼즈 테스트의 어마무시한 효과 (냇 프래이치)
  - 테스트 주도 개발(TDD)를 사용하든 사용하지 않든, 자동화 테스트를 작성하는 프로그래머라면 긍정적인 상황에 편향되는 어려움을 겪는다.
  - 즉 대부분의 프로그래머는 잘못된 입력이 주어졌을 때 소프트웨어가 얼마나 견고하게 동작하는지를 테스트하는 것 보다,
  - 유효한 입력이 주어졌을 때 소프트웨어가 올바르게 동작하는지를 테스트한다는 뜻이다.
  - 퍼즈 테스팅(Fuzz Testing)은 이미 존재하는 테스트 수트(suite)에 쉽게 부정적 테스트를 추가할 수 있는 엄청나게 효율적인 기법이다.
  - 예를 들어 광범위하게 사용되는 고객용 제품의 소프트웨어가 웹서비스에서 데이터를 로드하도록 확장하려 한다고 가정하자.
  - 견고한 네트워킹 코드를 신중히 작성하고, 긍정 & 부정적인 경우까지 모두 테스트한다 하더라도 퍼징은 소프트웨어가 예상치 못한 예외를 놀랄 정도로 많이 찾아낸다.
  - 퍼즈 테스트는 많은 임의의 입력을 생성해 테스트할 시스템에 전달한 후 소프트웨어가 허용할 수 있는 동작을 보이는지를 지속해서 확인한다.
  - 입력값을 생성하는 방법은 크게 두 가지다
    - 변형 기반 퍼저(mutation-based fuzzer)는 유효한 입력의 예시를 변경해서 유효하지 않은 테스트 입력을 생성한다.
    - 생성 기반 퍼저(generation-based fuzzer)는 문법 같은 형식화된 입력을 생성한다. 이 입력은 유효한 입력의 구조를 정의한다.
  - 전체 시스템에 임의의 입력 수천 개를 대입해 보는 것은 시간이 오래 걸린다.
  - 다시 말하지만 개발 과정에서 퍼즈 테스트를 적용한다면 시스템의 특정한 기능과 디자인에만 테스트를 적용할 수 있어 별개로 테스트가 가능하다.
  - 그런 후 퍼징을 이용해 테스트 단위의 올바른 동작과 타입을 확인한 후 시스템의 나머지 부분에서 올바르게 결합되는지만 확인화면 된다.
  - 퍼즈 테스팅은 이제 나의 테스트 주도 개발의 기본으로 자리잡고 있다.
  - 덕분에 결함을 없애고 더욱 결합적인(compositional) 시스템 디자인에 대한 가이드를 제시할 수 있게 되었다.
  - 자바와 코틀린 프로젝트에서 변형 기반 퍼즈 테스팅을 수행하기 위한 간단한 라이브러리는 깃허브(https://github.com/npryce/snodge) 에서 찾아볼 수 있다.

<br>

### 88 커버리지를 이용해 단위 테스트 개선하기 (에밀리 배쉬)
  - 테스트의 커버리지를 측정하기는 매우 쉽다.
  - IDE에서는 프로젝트를 실행하거나 디버그하는 버튼 바로 옆에 테스트를 실행하고 커버리지를 측정하는 버튼이 있다.
  - 커버리지 데이터를 얻기는 쉬운데 이 데이터를 활용하는 가장 좋은 방법은 무엇일까?
#### 새로운 코드를 작성할 때
  - 새로운 코드를 작성할 때 단위 테스트를 함께 작성해야 한다는 점에는 많은 사람이 동의한다.
  - 간단한 테스트 코드를 작성하고 약간의 프로덕션 코드를 추가해서 전체 기능을 테스트와 함께 구현해 나가는 방법이다.
  - 이런 방법으로 코드를 작성하면 가끔 테스트를 실행해 커버리지를 확인할 수 있음은 물론 새로운 코드를 작성할 때 잊지 않고 테스트를 작성할 수 있다.
  - 이 방법의 주요 문제점은 커버리지가 높아진 것에 만족한 나머지, 작업 중인 기능에서 중요한 부분을 구현하는 코드와 테스트를 놓치는 것을 간과하는 것이다.
  - 어쩌면 에러 처리를 잊었을 수 있고, 비즈니스 규칙 중 하나를 놓쳤을 수도 있다.
  - 만약 프로덕션 코드를 먼저 작성하지 않는다면 커버리지만으로는 해당 코드를 발견할 수 없다.
#### 다른 사람이 작성한 코드를 수정해야 할 때
  - 직접 작성하지 않은 코드인데다 관련된 테스트가 형편없거나 아예 없다면 수정에 애를 먹을 것이다.
  - 특히 코드의 동작을 이해하지 못하는 상황에서 수정해야 한다면 더욱 문제가 커진다.
  - 이런 상황에서는 테스트가 얼마나 잘 작성되었는지 그리고 어느 부분을 자신있게 리팩토링할 수 있는지 확인하는 방법 중 하나가 바로 테스트 커버리지다.
  - 또한 커버리지 데이터를 이용하면 새로운 테스트 케이스를 발견해 커버리지 지수를 높일 수 있다.
#### 팀의 일원으로 작업할 때
  - 팀은 명시적이든 묵시적이든 팀의 모든 구성원이 동의한 '표준' 이나 허용 행위가 있다.
  - 팀의 표준으로, 본인이 작성한 코드의 커버리지를 측정하고 리뷰 절차를 테스트하는 경우도 있다.
  - 커버리지는 복잡한 새 기능을 충분히 테스트하는지 확인할 방법이기도 하다.
  - 전체 코드베이스의 테스트 커버리지를 주기적으로 측정한다면 절대적 숫자보다는 트렌드에 집중하라고 권하고 싶다.
  - 커버리지는 단위 테스트를 개선하기 위한 것이며 단위 테스트는 리팩토링을 더 쉽게 하기 위한 것이다.
  - 커버리지 측정은 단위 테스트를 개선하고 여러분의 삶을 더 쉽게 만들 수 있는 아주 좋은 도구다.

<br>

### 89 사용자 정의 아이덴티티 애노테이션을 자유롭게 사용하자 (마크 리처드)
  - 자바의 애노테이션은 작성하기도 쉽고 사용도 쉬우며 매우 강력하다.
  - 원래 자바의 애노테이션은 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 편리하게 구현하기 위해 제공되었다.
  - AOP는 코드의 특정 지점에 행위를 주입해서 공통 행위를 코드로부터 분리하는 의도로 사용하던 기법이다.
  - 아이덴티티 애노테이션의 차이점은 어떤 기능도 갖지 않는다는 점이다.
  - 이 애노테이션은 단지 코드나 아키텍처의 어떤 관점을 다루고 분석하거나 문서화하기 위해 사용하는 프로그래밍적 정보를 제공할 뿐이다.
  - 아이덴티티 애노테이션을 사용하면 트랜잭션 경계나 도메인, 서브도메인을 특정하고 서비스의 분류, 프레임워크 코드의 표시 등 여러 방법으로 활용할 수 있다.
  - 예를 들어 기반 프레임워크의 클래스를 특정해서 변경 사항을 밀접하게 모니터링하거나 보호해야 하는 경우가 있다.
  - 이런 역할을 하는 애노테이션은 다음과 같다.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Framework {}

@Framework
public class Logger {...}
```

  - 이 애노테이션은 아무런 동작을 하지 않는다. 아닌가?
  - 이 애노테이션은 이 클래스가 프레임워크와 관련한 클래스임을 표시한다.
  - 즉, 이 클래스를 변경하면 거의 모든 다른 클래스가 영향을 받는다는 뜻이다.
  - 다음 예제는 내가 정기적으로 사용하는 공통 아이덴티티 애노테이션의 목록이다(모두 클래스 수준에 지정한다)

```java
// 마이크로서비스의 진입점을 특정한다. 또한 다음에 설명하는 다른 서비스 설명 애노테이션을 위한 자리지정자(placeholder)로도 사용한다.
// 사용법: @ServiceEntryPoint
public @interface ServiceEntryPoint {}


// 분산 트랜잭션에 참여하는 서비스를 특정한다.
// Transaction 값은 여러 서비스로 확대된 트랜잭션의 목록을 나열한다.
// 이 애노테이션은 @ServiceEntryPoint 애노테이션이 지정된 클래스에 추가한다.
// 사용법: @Saga({Transaction.CANCEL_ORDER})
public @interface Sage {public Transaction[] value()...}


// 서비스가 속한 논리적 도메인(지불, 배송, 발송자 등)을 특정한다.
// 역시 @ServiceEntryPoint 애노테이션을 가진 클래스에 추가한다.
// 사용법: @@ServiceDomain(Domain.PAYMENT)
public @interface ServiceDomain {public Domain value()...}


// 서비스의 분류(classification)를 특정한다.
// Type 값은 서비스의 타입(분류)을 나열한다.
// 마찬가지로 @ServiceEntryPoint 애노테이션을 가진 클래스에 추가한다.
// 사용법: @ServiceType(Type.ORCHESTRATION)
public @interface ServiceType {public Type value()...}


// 애플리케이션 전체에 공통(공유되는) 코드를 가진 클래스를 특정한다.
// e.g) 포매터, 연산 클래스, 로깅, 보안 등
// 사용법: @SharedService
public @interface SharedService {}
```

  - 아이덴티티 애노테이션은 일종의 프로그래밍적 문서화다.
  - 앞으로는 주석 대신 아이덴티티 애노테이션을 사용하는 것을 고려하자.
  - 이 애노테이션을 자유롭게 활용해서 정보를 얻고 분석하고 서비스와 애플리케이션을 프로그래밍적으로 제어할 수 있다.

<br>

### 90 테스트를 이용해 더 나은 소프트웨어를 더 빨리 개발하자 (메릿 반 다이크)
  - 테스트를 이용하면 코드가 원하는 동작을 수행하는지 검증할 수 있다.
  - 또한 다른 기능에 영향을 주지 않고 새로운 기능을 추가, 변경, 제거할 수도 있다.
  - **그저 무엇을 테스트할지** 만 생각해봐도 소프트웨어를 사용할 다른 방법을 특정하고 아직 명확하지 않은 것을 발견하며 코드가 어떤 동작을 해야하는지를 더 잘 이해할 수 있게 된다.
  - 실제 기능을 구현하기에 앞서 **테스트를 어떻게 할 것인지**를 생각해 보면 애플리케이션의 테스트 가능성과 아키텍처를 더욱 개선할 수 있다.
  - 시스템의 아키텍처와 더불어 무엇을 테스트할지뿐만 아니라 어디서 테스트할지도 생각해 보자.
  - 비즈니스 로직은 최대한 그 로직을 작성한 곳과 가까운 곳에서 테스트해야 한다.
  - 단위 테스트는 작은 단위(메서드, 클래스)를 테스트하며 통합 테스트는 다른 컴포넌트간 통합을 테스트하고, 계약 테스트는 API가 깨지지 않도록 방지한다.
  - 특정 유형의 테스트 목표를 명심하고 그 목적에 맞는 도구를 사용하자!
  - 예컨대 성능 테스트는 개틀링(Gatling)이나 제이미터(JMeter)를, 계약 테스트는 스프링 클라우드 컨텍스트나 팩트(Pact)를, 변형 테스팅에는 PITest를 사용하는 것이다.
  - 하지만 이런 도구는 의도된 대로 사용해야 하기 때문에 이런 도구를 사용하는 것만으로는 충분하지 않다.
  - 테스트 자동화는 시스템의 일부이며 프로덕션 코드와 함께 유지보수해야 한다.
  - 테스트가 충분한 가치를 부여하도록 하고 테스트 실행과 유지보수에 드는 비용을 고려하자.
  - 테스트는 안정적이어야 하며 자신감을 향상할 수 있어야 한다.
  - 테스트를 믿을 수 없다면 수정하거나 차라리 지워버리자. 절대 무시해서는 안 된다.
  - 테스트를 무시해버리면 나중에 그 이유를 알기 위해 더 많은 시간을 낭비하게 될 것이다.
  - 실패하는 테스트는 실패 원인을 분석하느라 시간을 많이 소비하지 않아도 정확히 무엇이 잘못됐는지를 빠르게 알려줄 수 있어야 한다. 다음과 같은 사항을 의미한다.
    - 각 테스트는 한 가지만 테스트해야 한다.
    - 의미 있고 서술적인 이름을 사용한다.
    - 테스트 동작을 설명할 필요는 없고 왜 이 테스트를 수행하는지 설명하자.
    - Hamcrest 같은 매처(Matcher) 라이브러리는 기대한 결과와 실제 결과 사이의 차이점에 대한 상세 정보를 제공한다.
    - 실패한 적이 없는 테스트는 절대 신뢰하지 말자.
  - 테스트는 적절한 시점에 적절한 피드백을 제공해야 한다.
  - 그래서 코드 커밋부터 머지, 배포, 기능의 공개에 이르는 소프트웨어 수명 주기의 다음 단계에 자신감을 충분히 제공할 수 있어야 한다.
  - 테스트를 잘할수록 더 나은 소프트웨어를 더 빨리 전달할 수 있다.

<br>

### 91 테스트 코드에 객체지향 원리 적용하기 (앤지 존스)
  - 프로덕션 코드를 개발할 때와 같은 마음가짐으로 테스트 코드를 작성하는 것이 중요하다.
  - 테스트 코드를 구현할 때 적용할 수 있는 몇 가지 객체지향 원리를 살펴본다.

#### 캡슐화

#### 상속
  - 상속은 잘못 사용하면 안되지만 테스트 코드에서는 확실히 유용하다.

#### 다형성
  - 사용자 프로필 페이지가 사용하는 편의 메서드가 있다고 가정해보자.
  - 이 메서드는 프로필 페이지가 관리자용인지 일반 멤버용인지 알지 못한다.
  - 이 시점에서 디자인 결정에 마주하게 된다.
  - AdminProfilePage 와 MemberProfilePage는 모두 ProfilePage의 서브클래스이므로 슈퍼클래스(ProfilePage)를 리턴하는 편이 좋다.

```java
@test
void badge_exists_on_admin_profile() {
    var adminProfile = (AdminProfilePage) page.goToProfile("@admin");
    ...
}
```

#### 추상화


<br>

### 92 커뮤니티의 힘을 빌려 경력을 개발하자 (샘 헵번)
  - 이제 훌륭한 자바 개발자가 되는 것만으로는 충분치 않다.
  - 경력을 더 개발하고 싶다면 블로깅, 컨퍼런스 발표, 소셜 미디어 활용, 오픈소스 기여 등 다양하게 활동해야 한다.
  - 어쩌면 너무 벅찬 일처럼 느껴지기도 하고, 스스로 '어째서 내 기술적 역량만으로 충분치 않은 거지?'라는 의문을 품을 수도 있다.
  - 간단히 답하자면 여러분의 경력과 관련한 결정을 내리는 사람은 여러분이 작성한 코드를 보지 않는 경우가 태반이기 때문이다.
  - **그러므로 그런 사람이 여러분의 이름을 듣고 볼 수 있도록 해야한다.**

#### 실버 라이닝
  - 앞서 나열한 활동을 모두 할 필요는 없다.
  - 많은 사람 앞에서 발표하는 데 부담을 느낀다면 굳이 그것을 할 필요는 없다.
  - 반면, 스스로가 소심하고 아무것도 할 말이 없다고 느껴진다면 커뮤니티의 도움을 받을 수 있다.
  - '같은 일을 경험해 본 사람에게서만 배울 수 있는' 어떤 문제를 스스로 해결해 본 경험이 있는가?
  - 그렇다면 그 경험은 발표나 블로그 포스트를 쓸 좋은 주제가 될 것이다.
  - 팀 단위의 작은 인원앞에서 부터 발표를 시작해보자.

#### 커뮤니티가 어떻게 도움이 될까?
  - 프로필 구축 외 커뮤니티 활동이 가치가 있는 또 다른 이유는 커뮤니티가 공유하는 컨테츠와 대화다.
  - 기술은 빠르게 이동하므로 커뮤니티의 일원이 된다는 것은 필요한 콘텐츠에 접근하기 위해 책이 출간될 때까지 기다릴 필요가 없다는 것을 의미한다.
  - 커뮤니티 구성원은 책을 집필하고 최신 기술을 학습하며, 그렇게 얻은 지식을 커뮤니티 이벤트, 블로그, 포럼 등으로 공유한다.
  - 여러분이 참여하는 커뮤니티의 구성원은 여러분이 더 나은 개발자가 되는 데 도움을 준다.
  - 발표자든 청중이든 이벤트의 콘텐츠보다는 서로에게서 배우는 것이 더 가치가 크다.
  - 누구에게든 질문하는 것을 두려워하지 말자.

#### 다음 도전 과제를 찾고 있는가?
  - 새로운 도전을 찾고 있다면 커뮤니티가 직업을 구하는 데 정말 큰 도움이 될 수 있다.
  - 올바른 기술을 갖췄으며 팀에 어울릴 만한 누군가를 알고 있다면, 채용 관리자는 수백 개의 이력서를 검토할 이유가 없이 바로 그 사람을 채용할 것이다.

<br>

### 93 JCP 프로그램에 대한 이해와 참여 방법 (헤더 반쿠라)
  - 자바 커뮤니티 프로세스(JCP, Java Community Process) 프로그램은 국제 자바 커뮤니티가 자바 기술에 대한 명세를 표준으로 제정하고 인준한 절차다.
  - 경험상 기술 명세를 기술하는 가장 좋은 방법은 개방적이고 포괄적인 절차를 이용해 다양한 관점을 가진 업계 전무가 그룹의 정보를 바탕으로 명세와 구현을 개발하는 것이다.
  - 또한 커뮤니티가 명세와 구현을 리뷰하고 의견을 공유할 기회를 제공함과 동시에, 기술 목표를 달성하고 새로운 명세가 다른 관련 명세와 통합할 수 있는 강력한 기술적 기반이 된다.
  - JCP.next는 투명성, JCP 프로그램 능률화, 멤버십 확대 등에 초점을 맞추도록 디자인된 자바 명세 요청(JSR, Java Specification Request)의 집합이다.
  - JSR은 JCP 프로세스 문서를 개선해서 JCP의 프로세스를 개선하고 있다.

<br>

### 94 자격증에 가치를 두지 않는 이유 (콜린 바이퍼스)
  - 한줄 요약: 좋은 개발자는 자격증이 필요없다. 하지만 그렇지 않은 개발자라도 자격증은 쉽게 얻을 수 있다.

### 95 주석은 한 문장으로 작성하라 (피터 힐튼)

```html
이해하기 힘든 코드를 작성하는 개발자가 흔히 범하는 오류는 주석으로 어떻게든 코드를 명쾌하고 알기 쉽게 표현할 수 있다고 생각하는 것이다 - 케블린 헤니(Kevlin Henney)
```
  
  - 주석을 '명쾌하고, 알기 쉽게' 쓰는 것은 힘든 일이므로, 주석이 너무 많다는 것은 코드를 잘못 설명하거나, 현재 코드에 맞춰 개선되지 않음을 의미한다.
  - 반면 주석이 전혀 없다는 것은 완벽한 이름 규칙(Naming), 코드 구조, 테스트가 주석을 대신해 코드를 설명하고 있다는 것을 의미한다.
  - 하지만 실제로 이렇게 구현하는 것은 어려운 일이다.
  - 주석을 전혀 쓰지 않는 개발자가 작성한 코드를 많이 봐 왔다.
    - 주석 쓰는 시간 절약, 코드 자체가 코드를 설명하고 있다고 생각
    - 가끔 주석이 필요 없을 정도의 코드를 작성한 경우도 봤다.
  - 하지만 대규모 애플리케이션, 특히 엔터프라이즈 비즈니스 애플리케이션은 좀 다르다.
  - 서로 다른 개발자가 작성했고, 현재에도 계속 늘어나고 있는 10만 줄의 코드를 운연하는 경우라면 주석은 풀어야 할 하나의 과제다.
  - 코드가 모두 완벽하지는 않으므로 코드를 설명하기 위한 다른 방법이 필요한데, 어느 정도 설명을 덧붙이는 것이 적당할지 판단하는 것은 어려운 문제다.
  - 대규모 애플리케이션에서 주석을 올바르게 작성하는 방법은 다음 절차에 따라 한 문장(one-sentence)으로 작성하는 것이다.
    - 최선의 코드를 작성한다.
    - 모든 공개(public) 클래스와 메서드/함수에 한 문장 주석을 작성한다.
    - 코드를 리팩토링한다.
    - 필요없는 주석을 제거한다.
    - 코드를 잘 설명하지 못하는 주석은 다시 작성한다.
    - 정말 필요한 곳에서만 상세 주석을 추가한다.
  - 항상 **코드만으로 설명할 수 없는 것만 언급하며** 왜 라는 질문에 코드로 답할 수 없는 것만 설명하기 위한 주석을 최소한으로 유지해야 한다.
  - 이런 내용을 공개 인터페이스마다 한 문장으로 제한하면 간결하다.
  - 또한 이러한 주석들은 최소한의 수로 유지해야 한다.
  - 좋은 주석은 매우 유용하다.
  - 코드는 작성할 때보다 읽을 때 시간이 더 오래 걸리기 때문이다.
  - 주석은 모든 범용 프로그래밍 언어가 유일하게 공통으로 제공하는 기능이다.

<br>

### 96 '읽기 좋은 코드'를 작성하자 (데이븐 팔리)
  - '읽기 좋은' 코드가 좋은 코드라는 말을 많이 들었는데, 과연 이는 어떤것을 의미하는 것일까?
  - 첫 번째 가독성 원칙은 코드를 심플하게 유지하는 것이다.
    - 긴 코드를 가진 메서드와 함수를 더 작은 코드 조각으로 나누고, 그것이 무슨 일을 하는지 알 수 있는 이름을 지어주는 것이다.
    - 배포 파이프라인에서 코드를 테스트할 수 있도록 코딩 표준을 자동화하는 것도 좋은 방법이다.
    - 메서드 길이가 20~30줄을 넘어가거나 매개변수에 5~6개 이상이라면 빌드가 실패하도록 설정할 수 있다.
    - 가독성읖 높이는 또 다른 방법은 말 그대로 읽을 수 있는 직관적인 코드를 작성하는 것이다.
    - '내가 코드를 작성하고 5분 후에 읽을 수 있을까?'를 고민하는게 아닌, 사람이 이해할 수 있는 코드를 작성하라는 뜻이다.

```java
// 이렇게 작성하지 말자 !!!!!!!
void function(X x, String a, double b, double c) {
    double r = method1(a, b);
    x.function1(a, r);
    
// 명확하게 작성하자.
void displayPercentage(Display display, String message, double value, double percentage) {
    double result = calculatePercentage(value, percentage);
    display.show(message, result);
```

  - 두 번째 코드는 어떤 역할을 하는지 명확하다.
  - 프로그래머가 아니더라도 메서드와 변수 이름을 보면 무슨 일이 일어나는지 유추할 수 있다.
  - 함수와 메서드를 간결하게 만들자.
  - 함수, 메서드, 변수, 매개변수, 상수, 필드 등 여러분이 해결하려는 문제의 범위 내에 있다면 모든 이름을 의미 있게 만들어야 한다.
  - 프로그래머가 아닌 여러분의 할아버지나 할머니가 코드를 읽는다고 상상해 보자.
  - 그분들이 코드의 동작을 유추할 수 없다면 리팩토링으로 코드를 더 간결하게 만들고, 의미 있는 좋은 이름을 지정하자.
  
<br>

### 97 젊은 객체, 늙은 객체, 그리고 가비지 (마리아 아리아스 드 레이나)
  - 자바의 장점 중 하나는 개발자가 메모리를 크게 신경 쓰지 않아도 된다는 점이다.
  - 시스템이 메모리 관리를 대신 해주기 때문인데, 하지만 그렇다고 자바 개발자가 자바의 메모리 관리 방식을 몰라도 되는 것은 아니다.
  - 여전히 메모리 누수(memory leak)나 병목(bottleneck) 현상이 존재하기 때문이다.
  - 자바는 메모리를 두 영역으로 나눈다.
    - 힙(Heap): 인스턴스, 변수
    - 논힙: 코드, 메타데이터... for JVM
  - 자바에서 메모리를 관리하려면 힙에 주목해야 한다.
  - 힙은 객체의 수명에 따라 영 제너레이션(young generation)과 올드 제너레이션(old generation) 두 영역으로 나뉜다.
  - 영 제너레이션에는 생명주기가 짧은 객체를 보관하며, 올드 제너레이션에는 생명주기가 긴 구조체를 보관한다.
  - 영 제너레이션은 다시 2개의 영역으로 나뉜다.
    - 에덴(Eden): 갓 생성된 오브젝트들이 위치하는 곳
    - 서바이버(Survivor): 영 제너레이션에서 올드 제너레이션으로 이동하기 전, 거쳐 가는 중간 상태

#### 가비지 컬렉터
  - 가비지 컬렉터는 메모리를 깨끗하게 청소하는 시스템이다.
  - 가비지 컬렉터를 구현하는 방법은 다양하지만 일반적으로 다음과 같은 작업을 수행한다.
    - 마이너 컬렉션(minor collection)
      - 영 제너레이션 영역을 정리한다.
    - 메이저 컬렉션(major collection)
      - 모든 영역(영, 올드 제너레이션)의 메모리를 정리한다.
  - GC는 일반 애플리케이션의 실행 중에 함께 실행되며, GC를 실행할 때마다 현재 동작하는 모든 스레드가 정지된다.
  - 애플리케이션이 정상적으로 실행중이라면 GC는 보통 애플리케이션의 실행을 방해하지 않기 위해 마이너 컬렉션만 수행한다.

#### GC 전략
  - 애플리케이션이 적절하게 동작하면서도 메모리를 제대로 관리하려면 객체를 장시간 사용하지 말고 작고 일시적으로 사용해야 한다.
  - 수명주기가 짧은 객체는 에덴(Eden)에 저장되며 GC는 이런 객체를 더 일찍 그리고 더 빠르게 정리한다.
  - 간혹 System.gc()를 직접 호출하여 GC를 강제 실행하고 싶을 수 있다.
  - 하지만 이는 메이저 컬렉션을 실행하므로 GC가 알아서 컬렉션을 실행하는 방식에 방해가 될 뿐만 아니라 GC가 동작하는 시간 동안 애플리케이션이 중단된다.

#### 참조
  - GC는 더는 참조하지 않는 인스턴스도 정리한다.
  - 모든 정적 객체(static object)는 애플리케이션이 실행 중인 동안에는 계속 유지된다.
  - 가비지 컬렉터는 여러분의 친구임을 명시하자.
  - 가비지 컬렉터는 여러분의 일상을 더 쉽게 만들어준다.
  - 그러므로 여러분도 가비지 컬렉터가 더 쉽게 자신의 역할을 다할 수 있게 도와주자.
